{"Overview.html":{"url":"Overview.html","title":"目录","keywords":"","body":"SummarySummary summary 序言 Base shell set 命令 shell 通配符扩展 shell dollar 字符 shell 默认参数 shell wait 等待命令 shell ifs shell 引号和转义 shell 命令返回值判断 shell 判断 shell while getopts shell 命令行操作 shell 循环 shell 创建临时文件 目录 shell sleep 睡眠 shell 多线程脚本 shell 数组 shell 跨脚本变量传递 shell 查看帮助 shell 运算符 shell 变量 shell 函数 shell 日志与打印输出 Case Monitor shell 判断文件 目录状态 shell 报告服务器信息 shell 磁盘空间 shell 天气预报 shell cpu shell 硬件信息 shell 获取 ip 位置 shell 显示系统信息菜单 hello world Math shell 减法 shell 乘法 shell 石头剪刀布 shell 比较大小 shell 加法 Game shell 模拟抽奖 Art shell 微调加载 shell 菱形图案 shell 大小写 shell 颜色输出 shell 命令输出 shell 简单交互 Task shell 挂载目录 shell 批量修改文件名 shell 上移目录 shell 清理日志 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-10-16 08:58:24 "},"./":{"url":"./","title":"序言","keywords":"","body":"序言参考联系公众号序言 这是一本关于集合 shell 的书。 参考 阮一峰老师的《Bash 脚本教程》 Linux Shell脚本学习指南 geeks for geeks Shell Books Bash Guide for Beginners 联系 Email: 1zoxun1@gmail.com WeChat: weke59 Youtube: BlackSwanGreen Ins: cnghostwritten Bilibili: LoveDeatRobots 公众号 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-30 12:35:37 "},"Base/":{"url":"Base/","title":"Base","keywords":"","body":"shell 简介1. Shell 的含义2. Shell 的种类3. 命令行环境3.1 终端模拟器3.2 命令行提示符3.3 进入和退出方法4. Shell 和 Bash 的历史shell 简介 1. Shell 的含义 学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。 具体来说，Shell 这个词有多种含义。 首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。 其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。 最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。 2. Shell 的种类 Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。 历史上，主要的 Shell 有下面这些。 Bourne Shell（sh） Bourne Again shell（bash） C Shell（csh） TENEX C Shell（tcsh） Korn shell（ksh） Z Shell（zsh） Friendly Interactive Shell（fish） Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。 下面的命令可以查看当前设备的默认 Shell。 $ echo $SHELL /bin/bash 当前正在使用的 Shell 不一定是默认 Shell，一般来说，ps命令结果的倒数第二行是当前 Shell。 $ ps PID TTY TIME CMD 4467 pts/0 00:00:00 bash 5379 pts/0 00:00:00 ps 上面示例中，ps命令结果的倒数第二行显示，运行的命令（cmd）是bash，表明当前正在使用的 Shell 是 Bash。 下面的命令可以查看当前的 Linux 系统安装的所有 Shell。 $ cat /etc/shells 上面三个命令中，$是命令行环境的提示符，用户只需要输入提示符后面的内容。 Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。 3. 命令行环境 3.1 终端模拟器 如果是不带有图形环境的 Linux 系统（比如专用于服务器的系统），启动后就直接是命令行环境。 不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。 所谓“终端模拟器”（terminal emulator）就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。 不同 Linux 发行版（准确地说是不同的桌面环境）带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。 3.2 命令行提示符 进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号$结尾，用户可以在这个符号后面输入各种命令。 [user@hostname] $ 上面例子中，完整的提示符是[user@hostname] $，其中前缀是用户名（user）加上@，再加主机名（hostname）。比如，用户名是bill，主机名是home-machine，前缀就是bill@home-machine。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 根用户（root）的提示符，不以美元符号（$）结尾，而以井号（#）结尾，用来 提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。 为了简洁，后文的命令行提示符都只使用$表示。 3.3 进入和退出方法 进入命令行环境以后，一般就已经打开 Bash 了。如果你的 Shell 不是 Bash，可以输入bash命令启动 Bash。 $ bash 退出 Bash 环境，可以使用exit命令，也可以同时按下Ctrl + d。 $ exit Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入pwd命令。按下回车键，就会显示当前所在的目录。 $ pwd /home/me 如果不小心输入了pwe，会返回一个提示，表示输入出错，没有对应的可执行程序。 $ pwe bash: pwe：未找到命令 4. Shell 和 Bash 的历史 Shell 伴随着 Unix 系统的诞生而诞生。 1969年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。 1971年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是sh，方便用户使用 Unix。 1973年至1975年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。 1976年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。 1978年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是csh。它是第一个真正替代sh的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。 1979年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是sh。对于用户来说，它们是同一个东西，只是底层代码不同而已。 1983年，David Korn 开发了Korn shell，程序名是ksh。 1985年，Richard Stallman 成立了自由软件基金会（FSF），由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。 1988年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为bash，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。 1989年，Bash 发布1.0版。 1996年，Bash 发布2.0版。 2004年，Bash 发布3.0版。 2009年，Bash 发布4.0版。 2019年，Bash 发布5.0版。 用户可以通过bash命令的--version参数或者环境变量$BASH_VERSION，查看本机的 Bash 版本。 $ bash --version GNU bash，版本 5.0.3(1)-release (x86_64-pc-linux-gnu) # 或者 $ echo $BASH_VERSION 5.0.3(1)-release Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-16 08:23:10 "},"Base/shell_set.html":{"url":"Base/shell_set.html","title":"shell set 命令","keywords":"","body":"shell set 命令1. set2. set -u3. set -x4. bash 的错误处理5. set -e6. set -o pipefailshell set 命令 1. set 会显示所有的环境变量和 Shell 函数 $ cat script.sh set a=1 b=2 c=3 echo $a echo $b echo $c echo $d $ script.sh bash script.sh BASH=/bin/bash BASHOPTS=cmdhist:complete_fullquote:extquote:force_fignore:hostcomplete:interactive_comments:progcomp:promptvars:sourcepath BASH_ALIASES=() BASH_ARGC=() BASH_ARGV=() BASH_CMDS=() BASH_LINENO=([0]=\"0\") BASH_SOURCE=([0]=\"script.sh\") BASH_VERSINFO=([0]=\"4\" [1]=\"3\" [2]=\"48\" [3]=\"1\" [4]=\"release\" [5]=\"x86_64-pc-linux-gnu\") BASH_VERSION='4.3.48(1)-release' 2. set -u 遇到不存在的变量就会报错，并停止执行，或者-o nounset $ cat script.sh set -u #-o nounset a=1 b=2 c=3 echo $a echo $b echo $c echo $d $ bash script.sh 1 2 3 script.sh: line 9: d: unbound variable 3. set -x 用来在运行结果之前，先输出执行的那一行命令,或者set -o xtrace $ cat script.sh set -x #set -o xtrace a=1 b=2 c=3 echo $a echo $b echo $c echo $d 执行结果： $ bash script.sh + a=1 + b=2 + c=3 + echo 1 1 + echo 2 2 + echo 3 3 + echo 4. bash 的错误处理 #!/usr/bin/env bash foo echo bar 上面脚本中，foo是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。 $ bash script.sh script.sh:行3: foo: 未找到命令 bar 可以看到，Bash 只是显示有错误，并没有终止执行。 这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。 command || exit 1 上面的写法表示只要command有非零返回值，脚本就会停止执行。 如果停止执行之前需要完成多个操作，就要采用下面三种写法。 # 写法一 command || { echo \"command failed\"; exit 1; } # 写法二 if ! command; then echo \"command failed\"; exit 1; fi # 写法三 command if [ \"$?\" -ne 0 ]; then echo \"command failed\"; exit 1; fi 另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。 command1 && command2 5. set -e set -e从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。或者set -o errexit #!/usr/bin/env bash set -e foo echo bar 执行结果如下。 $ bash script.sh script.sh:行4: foo: 未找到命令 可以看到，第4行执行失败以后，脚本就终止执行了。 set -e根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭set -e，该命令执行结束后，再重新打开set -e。 set +e command1 command2 set -e 上面代码中，set +e表示关闭-e选项，set -e表示重新打开-e选项。 还有一种方法是使用command || true，使得该命令即使执行失败，脚本也不会终止执行。 #!/bin/bash set -e foo || true echo bar 6. set -o pipefail set -e有一个例外情况，就是不适用于管道命令。 所谓管道命令，就是多个子命令通过管道运算符（|）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，set -e就失效了。 请看下面这个例子。 #!/usr/bin/env bash set -e foo | echo a echo bar 执行结果如下。 $ bash script.sh a script.sh:行4: foo: 未找到命令 bar 上面代码中，foo是一个不存在的命令，但是foo | echo a这个管道命令会执行成功，导致后面的echo bar会继续执行。 set -o pipefail用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。 #!/usr/bin/env bash set -eo pipefail foo | echo a echo bar 运行后，结果如下。 $ bash script.sh a script.sh:行4: foo: 未找到命令 参考： 阮一峰 set 命令，shopt 命令l Linux set Command & How to Use it {9 Examples} set - Set or unset values of shell options and positional parameters. The Set Builtin Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 07:56:50 "},"Base/shell_wildcard_expansion.html":{"url":"Base/shell_wildcard_expansion.html","title":"shell 通配符扩展","keywords":"","body":"Shell 通配符扩展1. 简介2. 波浪线扩展3. ? 字符扩展4. * 字符扩展5. 方括号扩展6. [start-end] 扩展7. 大括号扩展8. {start..end} 扩展9. 变量扩展10. 子命令扩展11. 算术扩展12. 字符类13. 使用注意点13.1 通配符是先解释，再执行。13.2 文件名扩展在不匹配时，会原样输出。13.3 只适用于单层路径。13.4 文件名可以使用通配符。14. 量词语法15. shopt 命令15.1 dotglob 参数15.2 nullglob 参数15.3 failglob 参数15.4 extglob 参数15.5 nocaseglob 参数15.6 globstar 参数Shell 通配符扩展 1. 简介 Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。 这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。 波浪线扩展 ?字符扩展 *字符扩展 方括号扩展 大括号扩展 变量扩展 子命令扩展 算术扩展 本章介绍这八种扩展。 Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。 模块扩展的英文单词是globbing，这个词来自于早期的 Unix 系统有一个/etc/glob文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。 模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。 Bash 允许用户关闭扩展。 $ set -o noglob # 或者 $ set -f 下面的命令可以重新打开扩展。 $ set +o noglob # 或者 $ set +f 2. 波浪线扩展 波浪线~会自动扩展成当前用户的主目录。 $ echo ~ /home/me ~/dir表示扩展成主目录的某个子目录，dir是主目录里面的一个子目录名。 # 进入 /home/me/foo 目录 $ cd ~/foo ~user表示扩展成用户user的主目录。 $ echo ~foo /home/foo $ echo ~root /root 上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。 如果~user的user是不存在的用户名，则波浪号扩展不起作用。 $ echo ~nonExistedUser ~nonExistedUser ~+会扩展成当前所在的目录，等同于pwd命令。 $ cd ~/foo $ echo ~+ /home/me/foo 3. ? 字符扩展 ?字符代表文件路径里面的任意单个字符，不包括空字符。比如，Data???匹配所有Data后面跟着三个字符的文件名。 # 存在文件 a.txt 和 b.txt $ ls ?.txt a.txt b.txt 上面命令中，?表示单个字符，所以会同时匹配a.txt和b.txt。 如果匹配多个字符，就需要多个?连用。 # 存在文件 a.txt、b.txt 和 ab.txt $ ls ??.txt ab.txt 上面命令中，??匹配了两个字符。 ? 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。 # 当前目录有 a.txt 文件 $ echo ?.txt a.txt # 当前目录为空目录 $ echo ?.txt ?.txt 上面例子中，如果?.txt可以扩展成文件名，echo命令会输出扩展后的结果；如果不能扩展成文件名，echo就会原样输出?.txt。 4. * 字符扩展 *字符代表文件路径里面的任意数量的任意字符，包括零个字符。 # 存在文件 a.txt、b.txt 和 ab.txt $ ls *.txt a.txt b.txt ab.txt 上面例子中，*.txt代表后缀名为.txt的所有文件。 如果想输出当前目录的所有文件，直接用*即可。 $ ls * *可以匹配空字符，下面是一个例子。 # 存在文件 a.txt、b.txt 和 ab.txt $ ls a*.txt a.txt ab.txt $ ls *b* b.txt ab.txt 注意，*不会匹配隐藏文件（以.开头的文件），即ls *不会输出隐藏文件。 如果要匹配隐藏文件，需要写成.*。 # 显示所有隐藏文件 $ echo .* 如果要匹配隐藏文件，同时要排除.和..这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成.[!.]*。 $ echo .[!.]* 注意，*字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。 # 当前目录不存在 c 开头的文件 $ echo c*.txt c*.txt 上面例子中，当前目录里面没有c开头的文件，导致c*.txt会原样输出。 *只匹配当前目录，不会匹配子目录。 # 子目录有一个 a.txt # 无效的写法 $ ls *.txt # 有效的写法 $ ls */*.txt 上面的例子，文本文件在子目录，*.txt不会产生匹配，必须写成*/*.txt。有几层子目录，就必须写几层星号。 Bash 4.0 引入了一个参数globstar，当该参数打开时，允许**匹配零个或多个子目录。因此，**/*.txt可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面shopt命令的介绍。 5. 方括号扩展 方括号扩展的形式是[...]，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，[aeiou]可以匹配五个元音字母中的任意一个。 # 存在文件 a.txt 和 b.txt $ ls [ab].txt a.txt b.txt # 只存在文件 a.txt $ ls [ab].txt a.txt 上面例子中，[ab]可以匹配a或b，前提是确实存在相应的文件。 方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。 # 不存在文件 a.txt 和 b.txt $ ls [ab].txt ls: 无法访问'[ab].txt': 没有那个文件或目录 上面例子中，由于扩展后的文件不存在，[ab].txt就原样输出了，导致ls命名报错。 方括号扩展还有两种变体：...和[!...]。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，abc或[!abc]表示匹配除了a、b、c以外的字符。 # 存在 aaa、bbb、aba 三个文件 $ ls ?[!a]? aba bbb 上面命令中，[!a]表示文件名第二个字符不是a的文件名，所以返回了aba和bbb两个文件。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 如果需要匹配[字符，可以放在方括号内，比如[[aeiou]。如果需要匹配连字号-，只能放在方括号内部的开头或结尾，比如[-aeiou]或[aeiou-]。 6. [start-end] 扩展 方括号扩展有一个简写形式[start-end]，表示匹配一个连续的范围。比如，[a-c]等同于[abc]，[0-9]匹配[0123456789]。 # 存在文件 a.txt、b.txt 和 c.txt $ ls [a-c].txt a.txt b.txt c.txt # 存在文件 report1.txt、report2.txt 和 report3.txt $ ls report[0-9].txt report1.txt report2.txt report3.txt ... 下面是一些常用简写的例子。 [a-z]：所有小写字母。 [a-zA-Z]：所有小写字母与大写字母。 [a-zA-Z0-9]：所有小写字母、大写字母与数字。 [abc]*：所有以a、b、c字符之一开头的文件名。 program.[co]：文件program.c与文件program.o。 BACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。 这种简写形式有一个否定形式[!start-end]，表示匹配不属于这个范围的字符。比如，[!a-zA-Z]表示匹配非英文字母的字符。 $ echo report[!1–3].txt report4.txt report5.txt 上面代码中，[!1-3]表示排除1、2和3。 7. 大括号扩展 大括号扩展{...}表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，{1,2,3}扩展成1 2 3。 $ echo {1,2,3} 1 2 3 $ echo d{a,e,i,u,o}g dag deg dig dug dog $ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back 注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。 $ ls {a,b,c}.txt ls: 无法访问'a.txt': 没有那个文件或目录 ls: 无法访问'b.txt': 没有那个文件或目录 ls: 无法访问'c.txt': 没有那个文件或目录 上面例子中，即使不存在对应的文件，{a,b,c}依然扩展成三个文件名，导致ls命令报了三个错误。 另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。 $ echo {1 , 2} {1 , 2} 上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。 逗号前面可以没有值，表示扩展的第一项为空。 $ cp a.log{,.bak} # 等同于 # cp a.log a.log.bak 大括号可以嵌套。 $ echo {j{p,pe}g,png} jpg jpeg png $ echo a{A{1,2},B{3,4}}b aA1b aA2b aB3b aB4b 大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。 $ echo /bin/{cat,b*} /bin/cat /bin/b2sum /bin/base32 /bin/base64 ... ... # 基本等同于 $ echo /bin/cat;echo /bin/b* 上面例子中，会先进行大括号扩展，然后进行*扩展，等同于执行两条echo命令。 大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。 $ echo {cat,dog} cat dog 由于大括号扩展{...}不是文件名扩展，所以它总是会扩展的。这与方括号扩展[...]完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。 # 不存在 a.txt 和 b.txt $ echo [ab].txt [ab].txt $ echo {a,b}.txt a.txt b.txt 上面例子中，如果不存在a.txt和b.txt，那么[ab].txt就会变成一个普通的文件名，而{a,b}.txt可以照样扩展。 8. {start..end} 扩展 大括号扩展有一个简写形式{start..end}，表示扩展成一个连续序列。比如，{a..z}可以扩展成26个小写英文字母。 $ echo {a..c} a b c $ echo d{a..d}g dag dbg dcg ddg $ echo {1..4} 1 2 3 4 $ echo Number_{1..5} Number_1 Number_2 Number_3 Number_4 Number_5 这种简写形式支持逆序。 $ echo {c..a} c b a $ echo {5..1} 5 4 3 2 1 注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。 $ echo {a1..3c} {a1..3c} 这种简写形式可以嵌套使用，形成复杂的扩展。 $ echo .{mp{3..4},m4{a,b,p,v}} .mp3 .mp4 .m4a .m4b .m4p .m4v 大括号扩展的常见用途为新建一系列目录。 $ mkdir {2007..2009}-{01..12} 上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。 这个写法的另一个常见用途，是直接用于for循环。 for i in {1..4} do echo $i done 上面例子会循环4次。 如果整数前面有前导0，扩展输出的每一项都有前导0。 $ echo {01..5} 01 02 03 04 05 $ echo {001..5} 001 002 003 004 005 这种简写形式还可以使用第二个双点号（start..end..step），用来指定扩展的步长。 $ echo {0..8..2} 0 2 4 6 8 上面代码将0扩展到8，每次递增的长度为2，所以一共输出5个数字。 多个简写形式连用，会有循环处理的效果。 $ echo {a..c}{1..3} a1 a2 a3 b1 b2 b3 c1 c2 c3 9. 变量扩展 Bash 将美元符号$开头的词元视为变量，将其扩展成变量值 $ echo $SHELL /bin/bash 变量名除了放在美元符号后面，也可以放在${}里面。 $ echo ${SHELL} /bin/bash ${!string*}或${!string@}返回所有匹配给定字符串string的变量名。 $ echo ${!S*} SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK 上面例子中，${!S*}扩展成所有以S开头的变量名。 10. 子命令扩展 $(...)可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。 $ echo $(date) Tue Jan 28 00:01:13 CST 2020 上面例子中，$(date)返回date命令的运行结果。 还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。 $ echo `date` Tue Jan 28 00:01:13 CST 2020 $(...)可以嵌套，比如$(ls $(pwd))。 11. 算术扩展 $((...))可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。 $ echo $((2 + 2)) 4 12. 字符类 [[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。 [[:alnum:]]：匹配任意英文字母与数字 [[:alpha:]]：匹配任意英文字母 [[:blank:]]：空格和 Tab 键。 [[:cntrl:]]：ASCII 码 0-31 的不可打印字符。 [[:digit:]]：匹配任意数字 0-9。 [[:graph:]]：A-Z、a-z、0-9 和标点符号。 [[:lower:]]：匹配任意小写字母 a-z。 [[:print:]]：ASCII 码 32-127 的可打印字符。 [[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。 [[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。 [[:upper:]]：匹配任意大写字母 A-Z。 [[:xdigit:]]：16进制字符（A-F、a-f、0-9）。 请看下面的例子。 $ echo [[:upper:]]* 上面命令输出所有大写字母开头的文件名。 字符类的第一个方括号后面，可以加上感叹号!，表示否定。比如，[![:digit:]]匹配所有非数字。 $ echo [![:digit:]]* 上面命令输出所有不以数字开头的文件名。 字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。 # 不存在以大写字母开头的文件 $ echo [[:upper:]]* [[:upper:]]* 上面例子中，由于没有可匹配的文件，字符类就原样输出了。 13. 使用注意点 通配符有一些使用注意点，不可不知。 13.1 通配符是先解释，再执行。 Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。 $ ls a*.txt ab.txt 上面命令的执行过程是，Bash 先将a*.txt扩展成ab.txt，然后再执行ls ab.txt。 13.2 文件名扩展在不匹配时，会原样输出。 文件名扩展在没有可匹配的文件时，会原样输出。 # 不存在 r 开头的文件名 $ echo r* r* 上面代码中，由于不存在r开头的文件名，r*会原样输出。 下面是另一个例子。 $ ls *.csv ls: *.csv: No such file or directory 另外，前面已经说过，大括号扩展{...}不是文件名扩展。 13.3 只适用于单层路径。 所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。 如果要匹配子目录里面的文件，可以写成下面这样。 $ ls */*.txt Bash 4.0 新增了一个globstar参数，允许**匹配零个或多个子目录，详见后面shopt命令的介绍。 13.4 文件名可以使用通配符。 Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号或双引号里面。 $ touch 'fo*' $ ls fo* 上面代码创建了一个fo文件，这时就是文件名的一部分。 14. 量词语法 量词语法用来控制模式匹配的次数。它只有在 Bash 的extglob参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。 $ shopt extglob extglob on 如果extglob参数是关闭的，可以用下面的命令打开。 $ shopt -s extglob 量词语法有下面几个。 ?(pattern-list)：模式匹配零次或一次。 *(pattern-list)：模式匹配零次或多次。 +(pattern-list)：模式匹配一次或多次。 @(pattern-list)：只匹配一次模式。 !(pattern-list)：匹配给定模式以外的任何内容。 $ ls abc?(.)txt abctxt abc.txt 上面例子中，?(.)匹配零个或一个点。 $ ls abc?(def) abc abcdef 上面例子中，?(def)匹配零个或一个def。 $ ls abc@(.txt|.php) abc.php abc.txt 上面例子中，@(.txt|.php)匹配文件有且只有一个.txt或.php后缀名。 $ ls abc+(.txt) abc.txt abc.txt.txt 上面例子中，+(.txt)匹配文件有一个或多个.txt后缀名。 $ ls a!(b).txt a.txt abb.txt ac.txt 上面例子中，!(b)表示匹配单个字母b以外的任意内容，所以除了ab.txt以外，其他文件名都能匹配。 量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。 # 没有 abc 开头的文件名 $ ls abc?(def) ls: 无法访问'abc?(def)': 没有那个文件或目录 上面例子中，由于没有可匹配的文件，abc?(def)就原样输出，导致ls命令报错。 15. shopt 命令 shopt命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。 shopt命令的使用方法如下。 # 打开某个参数 $ shopt -s [optionname] # 关闭某个参数 $ shopt -u [optionname] # 查询某个参数关闭还是打开 $ shopt [optionname] 15.1 dotglob 参数 dotglob参数可以让扩展结果包括隐藏文件（即点开头的文件）。 正常情况下，扩展结果不包括隐藏文件。 $ ls * abc.txt 打开dotglob，就会包括隐藏文件。 $ shopt -s dotglob $ ls * abc.txt .config 15.2 nullglob 参数 nullglob参数可以让通配符不匹配任何文件名时，返回空字符。 默认情况下，通配符不匹配任何文件名时，会保持不变。 $ rm b* rm: 无法删除'b*': 没有那个文件或目录 上面例子中，由于当前目录不包括b开头的文件名，导致b不会发生文件名扩展，保持原样不变，所以rm命令报错没有b这个文件。 打开nullglob参数，就可以让不匹配的通配符返回空字符串。 $ shopt -s nullglob $ rm b* rm: 缺少操作数 上面例子中，由于没有b匹配的文件名，所以rm b扩展成了rm，导致报错变成了”缺少操作数“。 15.3 failglob 参数 failglob参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。 $ shopt -s failglob $ rm b* bash: 无匹配: b* 上面例子中，打开failglob以后，由于b*不匹配任何文件名，Bash 直接报错了，不再让rm命令去处理。 15.4 extglob 参数 extglob参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。 $ shopt extglob extglob on 它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。 $ shopt -u extglob 15.5 nocaseglob 参数 nocaseglob参数可以让通配符扩展不区分大小写。 $ shopt -s nocaseglob $ ls /windows/program* /windows/ProgramData /windows/Program Files /windows/Program Files (x86) 上面例子中，打开nocaseglob以后，program*就不区分大小写了，可以匹配ProgramData等。 15.6 globstar 参数 globstar参数可以使得**匹配零个或多个子目录。该参数默认是关闭的。 假设有下面的文件结构。 a.txt sub1/b.txt sub1/sub2/c.txt 上面的文件结构中，顶层目录、第一级子目录sub1、第二级子目录sub1\\sub2里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？ 默认情况下，只能写成下面这样。 $ ls *.txt */*.txt */*/*.txt a.txt sub1/b.txt sub1/sub2/c.txt 这是因为*只匹配当前目录，如果要匹配子目录，只能一层层写出来。 打开globstar参数以后，匹配零个或多个子目录。因此，/*.txt就可以得到想要的结果。 $ shopt -s globstar $ ls **/*.txt a.txt sub1/b.txt sub1/sub2/c.txt 参考: Think You Understand Wildcards? Think Again Advanced Wildcard Patterns Most People Don’t Know Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-28 07:08:38 "},"Base/shell_dollar_string.html":{"url":"Base/shell_dollar_string.html","title":"shell dollar 字符","keywords":"","body":"Shell dollar 字符1. $ 常用参数2. ${ } 替换是 去掉左边（键盘上#在 $ 的左边）3. 实例Shell dollar 字符 1. $ 常用参数 $# 是传给脚本的参数个数 $0 是脚本本身的名字 $1 是传递给该shell脚本的第一个参数 $2 是传递给该shell脚本的第二个参数 $@ 是传给脚本的所有参数的列表 $* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个 $$ 是脚本运行的当前进程ID号 $? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误 2. ${ } 替换 file=/dir1/dir2/dir3/my.file.txt 可以用${ }分别替换得到不同的值： 复制代码代码如下: ${file#*/}：删掉第一个 / 及其左边的字符串：dir1/dir2/dir3/my.file.txt ${file##*/}：删掉最后一个 / 及其左边的字符串：my.file.txt ${file#*.}：删掉第一个 . 及其左边的字符串：file.txt ${file##*.}：删掉最后一个 . 及其左边的字符串：txt ${file%/*}：删掉最后一个 / 及其右边的字符串：/dir1/dir2/dir3 ${file%%/*}：删掉第一个 / 及其右边的字符串：(空值) ${file%.*}：删掉最后一个 . 及其右边的字符串：/dir1/dir2/dir3/my.file ${file%%.*}：删掉第一个 . 及其右边的字符串：/dir1/dir2/dir3/my 记忆的方法为： 复制代码代码如下: 是 去掉左边（键盘上#在 $ 的左边） %是去掉右边（键盘上% 在$ 的右边） 单一符号是最小匹配；两个符号是最大匹配 ${file:0:5}：提取最左边的 5 个字节：/dir1 ${file:5:5}：提取第 5 个字节右边的连续5个字节：/dir2 也可以对变量值里的字符串作替换： 复制代码代码如下: ${file/dir/path}：将第一个dir 替换为path：/path1/dir2/dir3/my.file.txt ${file//dir/path}：将全部dir 替换为 path：/path1/path2/path3/my.file.txt 利用 ${ } 还可针对不同的变数状态赋值(沒设定、空值、非空值)： ${file-my.file.txt} ：假如 $file 沒有设定，則使用 my.file.txt 作传回值。(空值及非空值時不作处理) ${file:-my.file.txt} ：假如 $file 沒有設定或為空值，則使用 my.file.txt 作傳回值。 (非空值時不作处理) ${file+my.file.txt} ：假如 $file 設為空值或非空值，均使用 my.file.txt 作傳回值。(沒設定時不作处理) ${file:+my.file.txt} ：若 $file 為非空值，則使用 my.file.txt 作傳回值。 (沒設定及空值時不作处理) ${file=my.file.txt} ：若 $file 沒設定，則使用 my.file.txt 作傳回值，同時將 $file 賦值為 my.file.txt 。 (空值及非空值時不作处理) ${file:=my.file.txt} ：若 $file 沒設定或為空值，則使用 my.file.txt 作傳回值，同時將 $file 賦值為my.file.txt 。 (非空值時不作处理) ${file?my.file.txt} ：若 $file 沒設定，則將 my.file.txt 輸出至 STDERR。 (空值及非空值時不作处理) ${file:?my.file.txt} ：若 $file 没设定或为空值，则将 my.file.txt 输出至 STDERR。 (非空值時不作处理) ${#var} 可计算出变量值的长度： ${#file} 可得到 27 ，因为/dir1/dir2/dir3/my.file.txt 是27个字节 3. 实例 $ cat test2.sh #!/bin/bash file=/dir1/dir2/dir3/my.file.txt echo ${file#*/} echo ${file##*/} echo ${file#*.} echo ${file##*.} echo ${file%/*} echo ${file%%/*} echo ${file%.*} echo ${file%%.*} echo ${file/dir/path} echo ${file//dir/path} echo ${file-my.file.txt} echo ${file:-my.file.txt} echo ${file+my.file.txt} echo ${file:+my.file.txt} echo ${file=my.file.txt} echo ${file:=my.file.txt} echo ${file?my.file.txt} echo ${file:?my.file.txt} echo ${#file} [root@dockermake ~]# bash test2.sh dir1/dir2/dir3/my.file.txt my.file.txt file.txt txt /dir1/dir2/dir3 /dir1/dir2/dir3/my.file /dir1/dir2/dir3/my /path1/dir2/dir3/my.file.txt /path1/path2/path3/my.file.txt /dir1/dir2/dir3/my.file.txt /dir1/dir2/dir3/my.file.txt my.file.txt my.file.txt /dir1/dir2/dir3/my.file.txt /dir1/dir2/dir3/my.file.txt /dir1/dir2/dir3/my.file.txt /dir1/dir2/dir3/my.file.txt 27 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-19 04:17:35 "},"Base/shell_default_parameter.html":{"url":"Base/shell_default_parameter.html","title":"shell 默认参数","keywords":"","body":"shell 默认参数shell 默认参数 #!/bin/bash v=${1:-'1.0.0'} h=${2:-'test demo'} echo ${v} echo ${h} 输出： [root@master ~]# bash test.sh 1.0.0 test demo [root@master ~]# bash test.sh abc 123 abc 123 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 07:59:54 "},"Base/shell_command_wait.html":{"url":"Base/shell_command_wait.html","title":"shell wait 等待命令","keywords":"","body":"shell wait 等待命令1. 简介2. 语法3. 示例3.1 等待命令3.2 单进程等待3.3 单进程 bash 等待3.4 多个进程等待3.5 多个进程 bash 等待 PIDshell wait 等待命令 1. 简介 bash wait 命令是一个 Shell 命令，它等待后台运行的进程完成并返回退出状态。与等待指定时间的sleep 命令不同，该wait命令等待所有或特定后台任务完成。 2. 语法 在 bash 脚本中使用wait命令有不同的方法。下表解释了每个用例。 命令 解释 wait 如果没有任何参数，该wait命令会等待所有后台进程完成，然后再继续执行脚本。 wait 添加的 PID 或作业 ID 会等待特定进程结束，然后再继续执行脚本。 wait -n 仅等待以下后台进程完成并返回退出状态。 wait -f 终止程序首先等待后台任务完成后再退出。 3. 示例 3.1 等待命令 在 bash 脚本中使用wait时需要了解三个附加参数： 1.&命令后的和号 ( ) 表示后台作业。 2.$!获取最后一个后台进程的PID。使用多个后台进程时，将先前的 PID 存储在一个变量中。 3.$?打印上一个进程的退出状态。 要查看这三个参数如何协同工作，请打开终端窗口并运行： sleep 10 & echo $! echo $? 该$!参数存储后台进程PID，同时$?存储退出状态。退出状态0表示命令成功完成。 3.2 单进程等待 首先打开终端并创建一个简单的后台进程： sleep 10 & 确认作业在后台运行： jobs -l 使用wait不带任何参数的命令暂停直到进程完成： wait 10 秒后（由于sleep 10），控制台打印完成消息。 3.3 单进程 bash 等待 使用该wait命令指示后台进程必须在脚本内执行的时间点。 例如，在文本编辑器中添加以下代码： #!/bin/bash echo Background process & echo First message echo Second message wait echo Third message 如果后台进程没有完成第一个和第二个进程，则该wait命令调用暂停以等待第二个进程之后后台进程完成，然后再继续执行第三个进程。 将脚本另存为single_process.sh。在终端中，更改权限以使脚本可执行： sudo chmod +x single_process.sh 运行脚本： ./single_process.sh 后台进程在命令之前的任何时间完成wait，并且脚本继续。 3.4 多个进程等待 1.打开文本编辑器，添加以下多进程脚本： #!/bin/bash sleep 10 & sleep 15 & sleep 5 & echo $(date +%T) wait echo $(date +%T) wait该脚本在命令之前和之后打印当前时间。没有任何参数，程序会等待所有进程完成。 将脚本另存为test.sh并关闭文件。接下来，使脚本可执行： sudo chmod +x test.sh 最后，运行程序： ./test.sh 由于进程在后台运行，所有三个进程都在十五秒内完成。 使用相同的脚本测试以下用例： 将-n参数添加到wait. 只有最快的过程完成，脚本在十秒后结束。 添加作业 ID 以指示脚本应等待哪个作业。例如，wait %1暂停以等待进程 1 ( sleep 10) 完成。 3.5 多个进程 bash 等待 PID 与多个进程一起工作时，使用 PID 来标识一个进程。下面的示例脚本显示了一个用例： #!/bin/bash echo \"Process 1 lasts for 2s\" && sleep 2 & PID=$! echo \"Process 2 lasts for 3s\" && sleep 3 & echo \"Current time $(date +%T)\" wait $PID echo \"Process 1 ended at time $(date +%T) with exit status $?\" wait $! echo \"Process 2 ended at time $(date +%T) with exit status $?\" 将脚本另存为multi_wait.sh。使脚本可执行： sudo chmod +x multi_wait.sh 运行脚本查看输出： ./multi_wait.sh 该脚本需要两秒钟来完成第一个过程（由于sleep2）和三秒钟来完成第二个过程。这两个过程同时执行，都在三秒内完成。 参考： Bash wait Command with Examples Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-10-16 08:22:56 "},"Base/shell_IFS.html":{"url":"Base/shell_IFS.html","title":"shell ifs","keywords":"","body":"shell IFS1. 简介2. 实例2.1 IFS 定制分隔符2.2 换行符做分隔符shell IFS 1. 简介 IFS的默认值为：空白（包括：空格，tab, 和新行)，将其ASSII码用十六进制打印出来就是：20 09 0a （见下面的shell脚本）。 IFS对空格的空白的处理和其他字符不一样，左右两边的纯空白会被忽略，多个连续的空白被当成一个IFS处理。 S*中使用IFS中的第一个字符。 awk中的FS（域分隔符）也和IFS有类似的用法和作用。 我写了一个shell脚本来演示IFS的用法和作用，如下： [hjq@localhost test]$ IFS='' [hjq@localhost test]$ set foo bar bam [hjq@localhost test]$ echo \"$@\" foo bar bam [hjq@localhost test]$ echo \"$*\" foobarbam [hjq@localhost test]$ unset IFS [hjq@localhost test]$ echo \"$*\" foo bar bam [hjq@localhost test]$ IFS=a [hjq@localhost test]$ echo \"$@\" foo bar bam [hjq@localhost test]$ echo \"$*\" fooabarabam [hjq@localhost test]$ unset IFS [hjq@localhost test]$ echo \"$*\" foo bar bam 2. 实例 2.1 IFS 定制分隔符 #!/bin/sh IFS='|' text='a a a a|b b b b|c c c c' for i in $text;do echo \"i=$i\";done root@master:~# bash test2.sh i=a a a a i=b b b b i=c c c c 2.2 换行符做分隔符 #!/bin/sh conf=\"ABC A B C 1|2|3 1 2 3\" echo \"$conf\" echo -------------- echo IFS: echo -n \"$IFS\"|xxd echo -------------- for c in $conf;do echo \"line='$c'\"; done echo -------------- #IFS=$'\\n' 表示用 换行符 做分隔 #IFS=\"\\n\" 与 IFS='\\n' 都是用 n 字符作为分隔 IFS=$'\\n' echo IFS: echo -n \"$IFS\"|xxd echo -------------- for c in $conf;do echo \"line='$c'\"; done root@master:~# bash test4.sh ABC A B C 1|2|3 1 2 3 -------------- IFS: 00000000: 2009 0a .. -------------- line='ABC' line='A' line='B' line='C' line='1|2|3' line='1' line='2' line='3' -------------- IFS: 00000000: 0a . -------------- line='ABC' line='A B C' line='1|2|3' line='1 2 3' 参考： Shell中的IFS解惑 Linux Shell - What is IFS? The Meaning of IFS in Bash Scripting Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 07:22:59 "},"Base/shell_quotes_and_escaping.html":{"url":"Base/shell_quotes_and_escaping.html","title":"shell 引号和转义","keywords":"","body":"Shell 引号和转义1. 转义2. 单引号3. 双引号4. Here 文档5. Here 字符串Shell 引号和转义 Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。 1. 转义 某些字符在 Bash 里面有特殊含义（比如$、&、*）。 $ echo $date $ 上面例子中，输出$date不会有任何结果，因为$是一个特殊字符。 如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”（escape）。 $ echo \\$date $date 上面命令中，只有在特殊字符$前面加反斜杠，才能原样输出。 反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线（\\）。 $ echo \\\\ \\ 上面例子输出了反斜杠本身。 反斜杠除了用于转义，还可以表示一些不可打印的字符。 \\a：响铃 \\b：退格 \\n：换行 \\r：回车 \\t：制表符 如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用echo命令的-e参数。 $ echo a\\tb atb $ echo -e \"a\\tb\" a b 上面例子中，命令行直接输出不可打印字符\\t，Bash 不能正确解释。必须把它们放在引号之中，然后使用echo命令的-e参数。 换行符是一个特殊字符，表示命令的结束，Bash 收到这个字符以后，就会对输入的命令进行解释执行。换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作长度为0的空字符处理，从而可以将一行命令写成多行。 $ mv \\ /path/to/foo \\ /path/to/bar # 等同于 $ mv /path/to/foo /path/to/bar 上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。 2. 单引号 Bash 允许字符串放在单引号或双引号之中，加以引用。 单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号（*）、美元符号（$）、反斜杠（\\）等。 $ echo '*' * $ echo '$USER' $USER $ echo '$((2+2))' $((2+2)) $ echo '$(echo foo)' $(echo foo) 上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。 由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号（$），然后再对里层的单引号转义。 # 不正确 $ echo it's # 不正确 $ echo 'it\\'s' # 正确 $ echo $'it\\'s' 不过，更合理的方法是改在双引号之中使用单引号。 $ echo \"it's\" it's 3. 双引号 双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。 $ echo \"*\" * 上面例子中，通配符*是一个特殊字符，放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，这意味着，双引号里面不会进行文件名扩展。 但是，三个特殊字符除外：美元符号（$）、反引号（）和反斜杠（\\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。 $ echo \"$SHELL\" /bin/bash $ echo \"`date`\" Mon Jan 27 13:33:18 CST 2020 上面例子中，美元符号（$）和反引号（）在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。 $ echo \"I'd say: \\\"hello!\\\"\" I'd say: \"hello!\" $ echo \"\\\\\" \\ 上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。 换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。 $ echo \"hello world\" hello world 上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就失去了这种特殊作用，只用来换行，所以可以输入多行。echo命令会将换行符原样输出，显示的时候正常解释为换行。 双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号（或单引号），将文件名放在里面。 $ ls \"two words.txt\" 上面命令中，two words.txt是一个包含空格的文件名，如果不放在双引号里面，就会被 Bash 当作两个文件。 双引号会原样保存多余的空格。 $ echo \"this is a test\" this is a test 双引号还有一个作用，就是保存原始命令的输出格式。 # 单行输出 $ echo $(cal) 一月 2020 日 一 二 三 四 五 六 1 2 3 ... 31 # 原始格式输出 $ echo \"$(cal)\" 一月 2020 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 上面例子中，如果$(cal)不放在双引号之中，echo就会将所有结果以单行输出，丢弃了所有原始的格式。 4. Here 文档 Here 文档（here document）是一种输入多行字符串的方法，格式如下。 它的格式分成开始标记（）和结束标记（token）。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。 下面是一个通过 Here 文档输出 HTML 代码的例子。 $ cat The title of your page Your page content goes here. _EOF_ Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。 $ foo='hello world' $ cat 上面例子中，变量$foo发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。 如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。 $ foo='hello world' $ cat 上面例子中，Here 文档的开始标记（_example_）放在单引号之中，导致变量替换失效了。 Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了echo命令。 $ command 上面代码中，Here 文档相当于echo命令的重定向。 所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如echo命令就不能用 Here 文档作为参数。 $ echo 上面例子不会有任何输出，因为 Here 文档对于echo命令无效。 此外，Here 文档也不能作为变量的值，只能用于命令的参数。 5. Here 字符串 Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（）表示。 它的作用是将字符串通过标准输入，传递给命令。 有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如cat命令只接受标准输入传入的字符串。 $ cat 上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。 $ md5sum 上面例子中，md5sum命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即md5sum ddd里面的ddd会被解释成文件名。这时就可以用 Here 字符串，将字符串传给md5sum命令。 参考： bash 引号和转义 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-28 06:01:05 "},"Base/shell_command_return.html":{"url":"Base/shell_command_return.html","title":"shell 命令返回值判断","keywords":"","body":"Shell 命令返回值判断1.判断命令是否存在1.1 优雅方法11.2 优雅方法21.3 优雅方法32. 返回错误退出2.1 || exit 退出2.2 bash -e2.3 set -e3. 返回错误提示3.1 一般方法3.2 优雅方法Shell 命令返回值判断 1.判断命令是否存在 1.1 优雅方法1 首先，检查命令是否有效的惯用方法直接在if语句中。 if command; then echo notify user OK >&2 else echo notify user FAIL >&2 return -1 fi （良好做法：使用>&2将消息发送给stderr。） 1.2 优雅方法2 将通用逻辑转移到共享函数中。 check() { local command=(\"$@\") if \"${command[@]}\"; then echo notify user OK >&2 else echo notify user FAIL >&2 exit 1 fi } check command1 check command2 check command3 1.3 优雅方法3 installed () { command -v \"$1\" >/dev/null 2>&1 } if installed then xx else xxx fi 2. 返回错误退出 2.1 || exit 退出 command1 || exit command2 || exit command3 || exit 2.2 bash -e $ bash -e xx.sh #!/bin/bash -e xx.sh command1 command2 command3 2.3 set -e $ bash xx.sh #!/bin/bash set -e command1 command2 command3 3. 返回错误提示 3.1 一般方法 方法1 if do some command; then echo notify user OK else echo notify user fail exit 255 # exit code must be unsigned short fi 方法2 do some command if [ $? -eq 0 ]; then echo notify user OK else echo notify user FAIL return -1 fi 3.2 优雅方法 方法1 die() { local message=$1 echo \"$message\" >&2 exit 1 } command1 || die 'command1 failed' command2 || die 'command2 failed' command3 || die 'command3 failed' 方法2（推荐） warn () { echo \"$@\" >&2 } die () { status=\"$1\" shift warn \"$@\" exit \"$status\" } do some command && echo notify user OK || die 255 Notify user fail Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-16 15:59:25 "},"Base/shell_control_condition.html":{"url":"Base/shell_control_condition.html","title":"shell 判断","keywords":"","body":"Shell 判断1. if1.1 if1.2 if else1.3 if else-if else1.4 if test1.5 if 文件判断2. case3. 组合表达式Shell 判断 1. if 1.1 if if else if if 语句语法格式： if condition then command1 command2 ... commandN fi 写成一行（适用于终端命令提示符）： if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; then echo \"true\"; fi 末尾的fi就是if倒过来拼写，后面还会遇到类似的。 1.2 if else if else if else 语法格式： if condition then command1 command2 ... commandN else command fi 1.3 if else-if else if else-if else 语法格式： if condition1 then command1 elif condition2 then command2 else commandN fi 以下实例判断两个变量是否相等： a=10 b=20 if [ $a == $b ] then echo \"a 等于 b\" elif [ $a -gt $b ] then echo \"a 大于 b\" elif [ $a -lt $b ] then echo \"a 小于 b\" else echo \"没有符合的条件\" fi 输出结果： a 小于 b 1.4 if test if else语句经常与test命令结合使用，如下所示： num1=$[2*3] num2=$[1+5] if test $[num1] -eq $[num2] then echo '两个数字相等!' else echo '两个数字不相等!' fi 输出结果： 两个数字相等! 1.5 if 文件判断 基本的 意义 [ -a FILE] 如果FILE存在，则为真。 [ -b FILE] 如果FILE存在并且是块特殊FILE，则为真。 [ -c FILE] 如果FILE存在并且是字符特殊FILE，则为真。 [ -d FILE] 如果FILE存在并且是一个目录，则为真。 [ -e FILE] 如果FILE存在，则为真。 [ -f FILE] 如果FILE存在并且是常规FILE，则为真。 [ -g FILE] 如果FILE存在且其 SGID 位已设置，则为真。 [ -h FILE] 如果FILE存在并且是符号链接，则为真。 [ -k FILE] 如果FILE存在并且其粘性位已设置，则为真。 [ -p FILE] 如果FILE存在并且是命名管道 (FIFO)，则为真。 [ -r FILE] 如果FILE存在且可读，则为真。 [ -s FILE] 如果FILE存在且大小大于零，则为真。 [ -t FD ] 如果FILE描述符FD打开并指向终端，则为真。 [ -u FILE] 如果FILE存在且其 SUID（设置用户 ID）位已设置，则为真。 [ -w FILE] 如果FILE存在且可写，则为真。 [ -x FILE] 如果FILE存在且可执行，则为真。 [ -O FILE] 如果FILE存在并且归有效用户 ID 所有，则为真。 [ -G FILE] 如果FILE存在并且归有效组 ID 所有，则为真。 [ -L FILE] 如果FILE存在并且是符号链接，则为真。 [ -N FILE] 如果FILE存在并且自上次读取后已被修改，则为真。 [ -S FILE] 如果FILE存在并且是一个套接字，则为真。 [FILE1- nt FILE 2 ] 如果FILE1的更改比FILE2更新，或者FILE1存在而FILE2不存在，则为真。 [FILE1 -otFILE 2 ] 如果FILE1早于FILE2，或者FILE2存在而FILE1不存在，则为真。 [FILE1 -efFILE 2 ] 如果FILE1和FILE2引用相同的设备和 inode 号，则为真。 [ -o选项名称] 如果启用了 shell 选项“OPTIONNAME”，则为真。 [-z字符串] 如果“STRING”为零，则长度为真。 [-n字符串] 或 [字符串] 如果“STRING”的长度不为零，则为真。 [ 字符串 1 == 字符串 2 ] 如果字符串相等，则为真。 为了严格遵守 POSIX ，可以使用“=”代替“==” 。 [ 字符串 1 ！= 字符串 2 ] 如果字符串不相等，则为真。 [ 字符串 1 如果“STRING1”在当前语言环境中按字典顺序排在“STRING2 ”之前，则为真。 [ 字符串 1 > 字符串 2 ] 如果“STRING1”在当前语言环境中按字典顺序排在“STRING2 ”之后，则为真。 [ ARG1 开 ARG2 ] “OP”是-eq、-ne、-lt、-le、-gt或-ge之一。如果\"ARG1\"分别等于、不等于、小于、小于或等于、大于或大于或等于\"ARG2\" ，则这些算术二元运算符返回真。 “ARG1”和“ARG2”是整数。 2. case name=`basename $0 .sh` case $1 in s|start) echo \"start...\" ;; stop) echo \"stop ...\" ;; reload) echo \"reload...\" ;; *) echo \"Usage: $name [start|stop|reload]\" exit 1 ;; esac exit 0 3. 组合表达式 Operation Effect [ ! EXPR ] 如果EXPR为假，则为真。. [ ( EXPR ) ] 返回EXPR的值。这可用于覆盖运算符的正常优先级. [ EXPR1 -a EXPR2 ] 如果EXPR1和EXPR2都为真，则为真。 [ EXPR1 -o EXPR2 ] 如果EXPR1或EXPR2为真，则为真。 参考： Introduction to if Conditional Statements | Shell Script Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-16 16:30:57 "},"Base/shell_while_getopts.html":{"url":"Base/shell_while_getopts.html","title":"shell while getopts","keywords":"","body":"Shell while getopts1. 简介2. 格式3. 示例3.1 常规带参数的脚本3.2 getopts的用法3.3 getopts与shift的结合3.4 getopts与shift结合23.6 getopts 忽略错误3.7 getopts 参数捆绑Shell while getopts 1. 简介 getpots是Shell命令行参数解析工具，旨在从Shell Script的命令行当中解析参数。getopts被Shell程序用来分析位置参数，option包含需要被识别的选项字符，如果这里的字符后面跟着一个冒号，表明该字符选项需要一个参数，其参数需要以空格分隔。冒号和问号不能被用作选项字符。getopts每次被调用时，它会将下一个选项字符放置到变量中，OPTARG则可以拿到参数值；如果option前面加冒号，则代表忽略错误。 2. 格式 getopts optstring name [arg...] optstring 列出了对应的Shell Script可以识别的所有参数。比如：如果 Shell Script可以识别-a，-f以及-s参数，则optstring就是afs；如果对应的参数后面还跟随一个值，则在相应的optstring后面加冒号。比如，a:fs 表示a参数后面会有一个值出现，-a value的形式。另外，getopts执行匹配到a的时候，会把value存放在一个叫OPTARG的Shell Variable当中。如果optstring是以冒号开头的，命令行当中出现了optstring当中没有的参数将不会提示错误信息。 name表示的是参数的名称，每次执行getopts，会从命令行当中获取下一个参数，然后存放到name当中。如果获取到的参数不在optstring当中列出，则name的值被设置为?。命令行当中的所有参数都有一个index，第一个参数从1开始，依次类推。另外有一个名为OPTIND的Shell Variable存放下一个要处理的参数的index。 3. 示例 3.1 常规带参数的脚本 在shell脚本中，对于简单的参数，常常会使用$1，$2，...,$n来处理即可，具体如下： [root@bobo tmp]# cat test.sh #!/bin/bash SYSCODE=$1 APP_NAME=$2 MODE_NAME=$3 echo \"${SYSCODE}下的${APP_NAME}分布在${MODE_NAME}里面\" [root@bobo tmp]# sh test.sh caiwu reops kebank_uut caiwu下的reops分布在kebank_uut里面 3.2 getopts的用法 [root@bobo tmp]# cat test.sh #!/bin/bash func() { echo \"Usage:\" echo \"test.sh [-j S_DIR] [-m D_DIR]\" echo \"Description:\" echo \"S_DIR,the path of source.\" echo \"D_DIR,the path of destination.\" exit -1 } upload=\"false\" while getopts 'h:j:m:u' OPT; do case $OPT in j) S_DIR=\"$OPTARG\";; m) D_DIR=\"$OPTARG\";; u) upload=\"true\";; h) func;; ?) func;; esac done echo $S_DIR echo $D_DIR echo $upload 执行脚本 [root@bobo tmp]# sh test.sh -j /data/usw/web -m /opt/data/web /data/usw/web /opt/data/web false [root@bobo tmp]# sh test.sh -j /data/usw/web -m /opt/data/web -u /data/usw/web /opt/data/web true [root@bobo tmp]# sh test.sh -j /data/usw/web /data/usw/web false [root@bobo tmp]# sh test.sh -m /opt/data/web /opt/data/web false [root@bobo tmp]# sh test.sh -h test.sh: option requires an argument -- h Usage: test.sh [-j S_DIR] [-m D_DIR] Description: S_DIR,the path of source. D_DIR,the path of destination. [root@bobo tmp]# sh test.sh j false [root@bobo tmp]# sh test.sh j m false getopts后面跟的字符串就是参数列表，每个字母代表一个选项，如果字母后面跟一个：，则就表示这个选项还会有一个值，比如上面例子中对应的-j /data/usw/web 和-m /opt/data/web 。而getopts字符串中没有跟随:的字母就是开关型选项，不需要指定值，等同于true/false,只要带上了这个参数就是true。 getopts识别出各个选项之后，就可以配合case进行操作。操作中，有两个\"常量\"，一个是OPTARG，用来获取当前选项的值；另外一个就是OPTIND，表示当前选项在参数列表中的位移。case的最后一项是?，用来识别非法的选项，进行相应的操作，我们的脚本中输出了帮助信息。 3.3 getopts与shift的结合 ：当选项参数识别完成以后，就能识别剩余的参数了，我们可以使用shift进行位移，抹去选项参数。 [root@bobo tmp]# cat test.sh #!/bin/bash func() { echo \"func:\" echo \"test.sh [-j S_DIR] [-m D_DIR]\" echo \"Description:\" echo \"S_DIR, the path of source.\" echo \"D_DIR, the path of destination.\" exit -1 } upload=\"false\" echo $OPTIND while getopts 'j:m:u' OPT; do case $OPT in j) S_DIR=\"$OPTARG\";; m) D_DIR=\"$OPTARG\";; u) upload=\"true\";; ?) func;; esac done echo $OPTIND shift $(($OPTIND - 1)) echo $1 执行： [root@bobo tmp]# sh test.sh -j /data/usw/web beijing 1 #执行的是第一个\"echo $OPTIND\" 3 #执行的是第二个\"echo $OPTIND\" beijing #此时$1是\"beijing\" [root@bobo tmp]# sh test.sh -m /opt/data/web beijing 1 #执行的是第一个\"echo $OPTIND\" 3 #执行的是第二个\"echo $OPTIND\" beijing [root@bobo tmp]# sh test.sh -j /data/usw/web -m /opt/data/web beijing 1 #执行的是第一个\"echo $OPTIND\" 5 #执行的是第二个\"echo $OPTIND\" beijing 参数位置： 1 2 3 4 5 6 [root@bobo tmp]# sh test.sh -j /data/usw/web -m /opt/data/web -u beijing 6 beijing 在上面的脚本中，我们位移的长度等于case循环结束后的OPTIND - 1，OPTIND的初始值为1。当选项参数处理结束后，其指向剩余参数的第一个。getopts在处理参数时，处理带值的选项参数，OPTIND加2；处理开关型变量时，OPTIND则加1。 如上执行的脚本：1）第一个脚本执行，-j的参数位置为1，由于-j后面带有参数，即处理带值选项参数，所以其OPTIND为1+2=3；2）第二个脚本执行，-m参数位置为1，由于其后带有参数，所以其OPTIND也为1+2=3；3）第三个脚本执行，-m的参数位置 (观察最后一个参数的位置) 为3，由于其后面带有参数，所以其OPTIND为3+2=5；4）第四个脚本执行，-u参数位置为5，由于其后面不带参数，即为处理开关型变量，所以其OPTIND为5+1=6。 3.4 getopts与shift结合2 [root@bobo tmp]# cat test.sh #!/bin/bash echo $* while getopts \":a:bc:\" opt do case $opt in a) echo $OPTARG echo $OPTIND ;; b) echo \"b $OPTIND\" ;; c) echo \"c $OPTIND\" ;; ?) echo \"error\" exit 1 esac done echo $OPTIND shift $(( $OPTIND-1 )) echo $0 echo $* [root@bobo tmp]# sh test.sh -a beijing -b -c shanghai -a beijing -b -c shanghai #执行的是第一个\"echo $*\",即打印\"传递给脚本的所有参数的列表\" beijing #执行的是\"echo $OPTARG\", OPTARG表示存储相应选项的参数，这里指-a的参数\"beijing\" 3 #-a参数位置为1，是处理带值选项参数，即-a参数的OPTIND为1+2=3 b 4 #-b参数位置为3，是处理开关型变量(即后面没有跟参数)，即-b参数的OPTIND为3+1=4 c 6 #-c参数位置为4，是处理带值选项参数，即-a参数的OPTIND为4+2=3 6 #执行的是\"echo $OPTIND\",此时打印的是脚本执行的最后一个参数(即-c)的OPTIND的index索引值。 test.sh #执行的是\"echo $0\",即打印脚本名称。$0是脚本本身的名字； #执行的是最后一个\"echo $*\",即打印\"传递给脚本的所有参数的列表\"。由于前面执行了shift $(( $OPTIND-1 )),即每执行一步，位置参数减1，所以到最后$*就为零了。 [root@bobo tmp]# 对比无 shift [root@bobo tmp]# cat test.sh #!/bin/bash # getopts-test.sh while getopts :d:s ha do case \"$ha\" in d) echo \"d option value is $OPTARG\" echo \"d option index is $(($OPTIND-1))\" ;; s) echo \"s option...\" echo \"s option index is $(($OPTIND-1))\" ;; [?]) print \"Usage: $0 [-s] [-d value] file ...\" exit 1 ;; esac done 执行脚本： [root@bobo tmp]# sh test.sh -d 100 -s d option value is 100 #打印的是对应选项的参数，即-d的参数值 d option index is 2 #-d参数位置为1，是处理带值选项参数，即-d参数的OPTIND为1+2=3。所以$(($OPTIND-1))为2 s option... s option index is 3 #-s参数位置为3，是处理带值选项参数，即-s参数的OPTIND为3+1=4。所以$(($OPTIND-1))为2 3.6 getopts 忽略错误 [root@bobo tmp]# cat test.sh #!/bin/bash while getopts c: OPTION;do #ab参数前面的:表示忽略错误 case $OPTION in a)echo \"get option a\" ;; b)echo \"get option b and parameter is $OPTARG\" ;; c)echo \"get option c and parameter is $OPTARG\" ;; ?)echo \"get a non option $OPTARG and OPTION is $OPTION\" ;; esac done [root@bobo tmp]# sh test.sh -a haha get option a [root@bobo tmp]# sh test.sh -b hehe get option b and parameter is hehe [root@bobo tmp]# sh test.sh -a haha -b hehe #由于getopts解析时ab参数在一起，-a和-b都跟参数时，-a在前面执行后，-b参数就不会执行了。 get option a [root@bobo tmp]# sh test.sh -b haha -a hehe #将-b参数放在前面执行，-a参数放在后面执行，两个参数就都可以执行了。 get option b and parameter is haha get option a [root@bobo tmp]# sh test.sh -ab hehe get option a get option b and parameter is hehe [root@bobo tmp]# sh test.sh -ab hehe -c heihei get option a get option b and parameter is hehe get option c and parameter is heihei [root@bobo tmp]# sh test.sh -ab hehe -c heihei -u liu get option a get option b and parameter is hehe get option c and parameter is heihei get a non option u and OPTION is ? 3.7 getopts 参数捆绑 稍微修改下脚本，将abc参数放在一起 [root@bobo tmp]# cat test.sh #!/bin/bash while getopts OPTION;do case $OPTION in a)echo \"get option a\" ;; b)echo \"get option b and parameter is $OPTARG\" ;; c)echo \"get option c and parameter is $OPTARG\" ;; ?)echo \"get a non option $OPTARG and OPTION is $OPTION\" ;; esac done [root@bobo tmp]# sh test.sh -a haha get option a [root@bobo tmp]# sh test.sh -a haha -b hehe get option a [root@bobo tmp]# sh test.sh -a haha -c heihei get option a [root@bobo tmp]# sh test.sh -a haha -b hehe -c heihei get option a [root@bobo tmp]# sh test.sh -a haha -c hehe -b heihei get option a [root@bobo tmp]# sh test.sh -b hehe get option b and parameter is [root@bobo tmp]# sh test.sh -b haha -a hehe get option b and parameter is [root@bobo tmp]# sh test.sh -b haha -c hehe get option b and parameter is [root@bobo tmp]# sh test.sh -b haha -a hehe -c heihei get option b and parameter is [root@bobo tmp]# sh test.sh -b haha -c hehe -a heihei get option b and parameter is [root@bobo tmp]# sh test.sh -c haha get option c and parameter is haha [root@bobo tmp]# sh test.sh -c haha -a hehe get option c and parameter is haha get option a [root@bobo tmp]# sh test.sh -c haha -b heihei get option c and parameter is haha get option b and parameter is [root@bobo tmp]# sh test.sh -c haha -a hehe -b heihei get option c and parameter is haha get option a [root@bobo tmp]# sh test.sh -c haha -b hehe -c heihei get option c and parameter is haha get option b and parameter is [root@bobo tmp]# sh test.sh -abc hehe get option a get option b and parameter is get option c and parameter is hehe 参考： Shell脚本中的while getopts用法小结 Shell Scripting Tutorial - Tips Getopts How to Use getopts to Parse Linux Shell Script Options Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 07:35:46 "},"Base/shell_command_line.html":{"url":"Base/shell_command_line.html","title":"shell 命令行操作","keywords":"","body":"shell 命令行操作简介2. 光标移动3. 清除屏幕4. 编辑操作5. 自动补全6. 操作历史6.1 基本用法6.2 history 命令7. 相关快捷键shell 命令行操作 简介 Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。 这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。 $ set -o vi 下面的命令可以改回 Emacs 快捷键。 $ set -o emacs 如果想永久性更改编辑模式（Emacs / Vi），可以将命令写在~/.inputrc文件，这个文件是 Readline 的配置文件。 set editing-mode vi 本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。 Bash 默认开启这个库，但是允许关闭。 $ bash --noediting 上面命令中，--noediting参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。 2. 光标移动 Readline 提供快速移动光标的快捷键。 Ctrl + a：移到行首。 Ctrl + b：向行首移动一个字符，与左箭头作用相同。 Ctrl + e：移到行尾。 Ctrl + f：向行尾移动一个字符，与右箭头作用相同。 Alt + f：移动到当前单词的词尾。 Alt + b：移动到当前单词的词首。 上面快捷键的 Alt 键，也可以用 ESC 键代替。 3. 清除屏幕 Ctrl + l快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与clear命令作用相同。 4. 编辑操作 下面的快捷键可以编辑命令行内容。 Ctrl + d：删除光标位置的字符（delete）。 Ctrl + w：删除光标前面的单词。 Ctrl + t：光标位置的字符与它前面一位的字符交换位置（transpose）。 Alt + t：光标位置的词与它前面一位的词交换位置（transpose）。 Alt + l：将光标位置至词尾转为小写（lowercase）。 Alt + u：将光标位置至词尾转为大写（uppercase）。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 使用Ctrl + d的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。 剪切和粘贴快捷键如下。 Ctrl + k：剪切光标位置到行尾的文本。 Ctrl + u：剪切光标位置到行首的文本。 Alt + d：剪切光标位置到词尾的文本。 Alt + Backspace：剪切光标位置到词首的文本。 Ctrl + y：在光标位置粘贴文本。 同样地，Alt 键可以用 Esc 键代替。 5. 自动补全 命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入cle，再按下 Tab 键，Bash 会自动将这个命令补全为clear。 如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。 除了命令或路径，Tab 还可以补全其他值。如果一个值以$开头，则按下 Tab 键会补全变量；如果以~开头，则补全用户名；如果以@开头，则补全主机名（hostname），主机名以列在/etc/hosts文件里面的主机为准。 自动补全相关的快捷键如下。 Tab：完成自动补全。 Alt + ?：列出可能的补全，与连按两次 Tab 键作用相同。 Alt + /：尝试文件路径补全。 Ctrl + x /：先按Ctrl + x，再按/，等同于Alt + ?，列出可能的文件路径补全。 Alt + !：命令补全。 Ctrl + x !：先按Ctrl + x，再按!，等同于Alt + !，命令补全。 Alt + ~：用户名补全。 Ctrl + x ~：先按Ctrl + x，再按~，等同于Alt + ~，用户名补全。 Alt + $：变量名补全。 Ctrl + x $：先按Ctrl + x，再按$，等同于Alt + $，变量名补全。 Alt + @：主机名补全。 Ctrl + x @：先按Ctrl + x，再按@，等同于Alt + @，主机名补全。 Alt + *：在命令行一次性插入所有可能的补全。 Alt + Tab：尝试用.bash_history里面以前执行命令，进行补全。 上面的Alt键也可以用 ESC 键代替。 6. 操作历史 6.1 基本用法 Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。有了操作历史以后，就可以使用方向键的↑和↓，快速浏览上一条和下一条命令。 退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入~/.bash_history文件，该文件默认储存500个操作。 环境变量HISTFILE总是指向这个文件。 $ echo $HISTFILE /home/me/.bash_history history命令会输出这个文件的全部内容。用户可以看到最近执行过的所有命令，每条命令之前都有行号。越近的命令，排在越后面。 $ history ... 498 echo Goodbye 499 ls ~ 500 cd 输入命令时，按下Ctrl + r快捷键，就可以搜索操作历史，选择以前执行过的命令。这时键入命令的开头部分，Shell 就会自动在历史文件中，查询并显示最近一条匹配的结果，这时按下回车键，就会执行那条命令。 下面的方法可以快速执行以前执行过的命令。 $ echo Hello World Hello World $ echo Goodbye Goodbye $ !e echo Goodbye Goodbye 上面例子中，!e表示找出操作历史之中，最近的那一条以e开头的命令并执行。Bash 会先输出那一条命令echo Goodbye，然后直接执行。 同理，!echo也会执行最近一条以echo开头的命令。 $ !echo echo Goodbye Goodbye $ !echo H echo Goodbye H Goodbye H $ !echo H G echo Goodbye H G Goodbye H G 注意，!string语法只会匹配命令，不会匹配参数。所以!echo H不会执行echo Hello World，而是会执行echo Goodbye，并把参数H附加在这条命令之后。同理，!echo H G也是等同于echo Goodbye命令之后附加H G。 由于!string语法会扩展成以前执行过的命令，所以含有!的字符串放在双引号里面，必须非常小心，如果它后面有非空格的字符，就很有可能报错。 $ echo \"I say:\\\"hello!\\\"\" bash: !\\: event not found 上面的命令会报错，原因是感叹号后面是一个反斜杠，Bash 会尝试寻找，以前是否执行过反斜杠开头的命令，一旦找不到就会报错。解决方法就是在感叹号前面，也加上反斜杠。 $ echo \"I say:\\\"hello\\!\\\"\" I say:\"hello\\!\" 6.2 history 命令 前面说过，history命令能显示操作历史，即.bash_history文件的内容。 $ history 使用该命令，而不是直接读取.bash_history文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。 通过定制环境变量HISTTIMEFORMAT，可以显示每个操作的时间。 $ export HISTTIMEFORMAT='%F %T ' $ history 1 2013-06-09 10:40:12 cat /etc/issue 2 2013-06-09 10:40:12 clear 上面代码中，%F相当于%Y - %m - %d，%T相当于%H : %M : %S。 只要设置HISTTIMEFORMAT这个环境变量，就会在.bash_history文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。 环境变量HISTSIZE设置保存历史操作的数量。 $ export HISTSIZE=10000 上面命令设置保存过去10000条操作历史。 如果不希望保存本次操作的历史，可以设置HISTSIZE等于0。 export HISTSIZE=0 如果HISTSIZE=0写入用户主目录的~/.bashrc文件，那么就不会保留该用户的操作历史。如果写入/etc/profile，整个系统都不会保留操作历史。 环境变量HISTIGNORE可以设置哪些命令不写入操作历史。 export HISTIGNORE='pwd:ls:exit' 上面示例设置，pwd、ls、exit这三个命令不写入操作历史。 如果想搜索某个以前执行的命令，可以配合grep命令搜索操作历史。 $ history | grep /usr/bin 上面命令返回.bash_history文件里面，那些包含/usr/bin的命令。 操作历史的每一条记录都有编号。知道了命令的编号以后，可以用感叹号 + 编号执行该命令。如果想要执行.bash_history里面的第8条命令，可以像下面这样操作。 $ !8 history命令的-c参数可以清除操作历史。 $ history -c 7. 相关快捷键 下面是一些与操作历史相关的快捷键。 Ctrl + p：显示上一个命令，与向上箭头效果相同（previous）。 Ctrl + n：显示下一个命令，与向下箭头效果相同（next）。 Alt + ：显示第一个命令。 Alt + >：显示最后一个命令，即当前的命令。 Ctrl + o：执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。 感叹号!的快捷键如下。 !!：执行上一个命令。 !n：n为数字，执行历史文件里面行号为n的命令。 !-n：执行当前命令之前n条的命令。 !string：执行最近一个以指定字符串string开头的命令。 !?string：执行最近一条包含字符串string的命令。 !$：代表上一个命令的最后一个参数。 !*：代表上一个命令的所有参数，即除了命令以外的所有部分。 ^string1^string2：执行最近一条包含string1的命令，将其替换成string2。 下面是!$和!*的例子。 $ cp a.txt b.txt $ echo !$ b.txt $ cp a.txt b.txt $ echo !* a.txt b.txt 上面示例中，!$代表上一个命令的最后一个参数（b.txt），!*代表上一个命令的所有参数（a.txt b.txt）。 下面是^string1^string2的例子。 $ rm /var/log/httpd/error.log $ ^error^access rm /var/log/httpd/access.log 上面示例中，^error^access将最近一条含有error的命令里面的error，替换成access。 如果希望确定是什么命令，然后再执行，可以打开histverify选项。这样的话，使用!快捷键所产生的命令，会先打印出来，等到用户按下回车键后再执行。 $ shopt -s histverify 其他快捷键 Ctrl + j：等同于回车键（LINEFEED）。 Ctrl + m：等同于回车键（CARRIAGE RETURN）。 Ctrl + o：等同于回车键，并展示操作历史的下一个命令。 Ctrl + v：将下一个输入的特殊字符变成字面量，比如回车变成^M。 Ctrl + [：等同于 ESC。 Alt + .：插入上一个命令的最后一个词。 Alt + _：等同于Alt + .。 上面的Alt + .快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。 $ mkdir foo_bar $ cd #按下 Alt + . 上面例子中，在cd命令后按下Alt + .，就会自动插入foo_bar。 参考： Bash 行操作 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-28 08:03:31 "},"Base/shell_loop.html":{"url":"Base/shell_loop.html","title":"shell 循环","keywords":"","body":"Shell 循环1. while1.1 大小判断1.2 100相加1.3 无限循环1.4 多列输出1.5 读行2. for3. break4. continueShell 循环 1. while 示例 #!/bin/bash #基础 i=1 while [ $i -le 5 ] do echo $i let i++ done 输出： $ sh while.sh 1 2 3 4 5 1.1 大小判断 i=10 while [ $i -ne 0 ] do i=`expr $i - 1` echo $i # sleep 1 done 输出： sh while2.sh 9 8 7 6 5 4 3 2 1 0 1.2 100相加 #!/bin/bash #计算1+2+...+100的值 i=1 sum=0 while (( i 输出： $ bash while.sh The total value is 5050 1.3 无限循环 while true do uptime sleep 1 done 输出： sh while.sh 10:20:54 up 4 min, 1 user, load average: 0.05, 0.19, 0.12 10:20:56 up 4 min, 1 user, load average: 0.05, 0.19, 0.12 10:20:57 up 4 min, 1 user, load average: 0.05, 0.19, 0.12 10:20:58 up 4 min, 1 user, load average: 0.05, 0.19, 0.12 参考： Shell中while循环的陷阱, 变量实效,无法赋值变量 1.4 多列输出 $ cat test.txt xiaoming 122458930 山西 dali 343536546232 新疆 lihua 35354646565 广东 $ cat while2.sh #!/bin/bash while read name phone origin do echo \"$name : $phone : $origin\" done 执行： $ bash while2.sh xiaoming : 122458930 : 山西 dali : 343536546232 : 新疆 lihua : 35354646565 : 广东 1.5 读行 $ cat test 1 22 33 3 while-read.sh #!/bin/bash # while-read: read lines from a file count=0 while read; do printf \"%d %s\\n\" $REPLY count=$(expr $count + 1) done 执行： $ bash wile_read.sh test 1 22 33 3 count:3 2. for 格式： for var in item1 item2 ... itemN do command1 command2 ... commandN done 写成一行： for var in item1 item2 ... itemN; do command1; command2… done; in列表可以包含替换、字符串和文件名。 in列表是可选的，如果不用它，for循环使用命令行的位置参数。 例如，顺序输出当前列表中的数字： #!/bin/bash for varible1 in {1..5} #for varible1 in 1 2 3 4 5 do echo \"Hello, Welcome $varible1 times \" done 计算1～100内所有的奇数之和 #!/bin/bash sum=0 for i in {1..100..2} do let \"sum+=i\" done echo \"sum=$sum\" 执行： $ bash while1.sh sum=2500 通过i的按步数2不断递增，计算sum值为2500。同样可以使用seq命令实现按2递增来计算1～100内的所有奇数之和，for i in $(seq 1 2 100)，seq表示起始数为1，跳跃的步数为2，结束条件值为100。 #!/bin/bash sum=0 for i in $(seq 1 2 100) do let \"sum+=i\" done echo \"sum=$sum\" [root@localhost control]# bash while2.sh sum=2500 查看当前目录下文件以及文件夹 #!/bin/bash for file in $( ls ) #for file in * do echo \"file: $file\" done for循环列表参数 #!/bin/bash echo \"number of arguments is $#\" echo \"What you input is: \" for argument do echo \"$argument\" done #!/bin/bash for((integer = 1; integer 3. break break 跳出整个循环 $ cat break1.sh #!/bin/bash for ((a=1; a 执行： $ bash break1.sh outer loop: 1 inter loop: 1 inter loop: 2 outer loop: 2 inter loop: 1 inter loop: 2 outer loop: 3 inter loop: 1 inter loop: 2 4. continue continue跳出本次循环 $ cat continue1.sh #!/bin/bash for ((a=1; a 执行： $ bash continue1.sh outer loop: 1 inter loop: 1 inter loop: 2 inter loop: 4 outer loop: 2 inter loop: 1 inter loop: 2 inter loop: 4 outer loop: 3 inter loop: 1 inter loop: 2 inter loop: 4 参考： Looping Statements | Shell Script Bash 脚本教程：循环 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 08:11:55 "},"Base/shell_tmp_file_or_dir.html":{"url":"Base/shell_tmp_file_or_dir.html","title":"shell 创建临时文件 目录","keywords":"","body":"Shell 创建临时文件/目录1. 临时文件的安全问题2. mktemp 命令的用法3. mktemp 命令的参数4. trap 命令Shell 创建临时文件/目录 Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在/tmp目录里面创建文件或目录，这样做有很多弊端，使用mktemp命令是最安全的做法。 1. 临时文件的安全问题 直接创建临时文件，尤其在/tmp目录里面，往往会导致安全问题。 首先，/tmp目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。 $ touch /tmp/info.txt $ ls -l /tmp/info.txt -rw-r--r-- 1 ruanyf ruanyf 0 12月 28 17:12 /tmp/info.txt 上面命令在/tmp目录直接创建文件，该文件默认是所有人可读的。 其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。 最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。 生成临时文件应该遵循下面的规则。 创建前检查文件是否已经存在。 确保临时文件已成功创建。 临时文件必须有权限的限制。 临时文件要使用不可预测的文件名。 脚本退出时，要删除临时文件（使用trap命令）。 2. mktemp 命令的用法 mktemp命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。 直接运行mktemp命令，就能生成一个临时文件。 $ mktemp /tmp/tmp.4GcsWSG4vj $ ls -l /tmp/tmp.4GcsWSG4vj -rw------- 1 ruanyf ruanyf 0 12月 28 12:49 /tmp/tmp.4GcsWSG4vj 上面命令中，mktemp命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。 Bash 脚本使用mktemp命令的用法如下。 #!/bin/bash TMPFILE=$(mktemp) echo \"Our temp file is $TMPFILE\" 为了确保临时文件创建成功，mktemp命令后面最好使用 OR 运算符（||），保证创建失败时退出脚本。 #!/bin/bash TMPFILE=$(mktemp) || exit 1 echo \"Our temp file is $TMPFILE\" 为了保证脚本退出时临时文件被删除，可以使用trap命令指定退出时的清除操作。 #!/bin/bash trap 'rm -f \"$TMPFILE\"' EXIT TMPFILE=$(mktemp) || exit 1 echo \"Our temp file is $TMPFILE\" 3. mktemp 命令的参数 -d参数可以创建一个临时目录。 $ mktemp -d /tmp/tmp.Wcau5UjmN6 -p参数可以指定临时文件所在的目录。默认是使用$TMPDIR环境变量指定的目录，如果这个变量没设置，那么使用/tmp目录。 $ mktemp -p /home/ruanyf/ /home/ruanyf/tmp.FOKEtvs2H3 -t参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的X字符，表示随机字符，建议至少使用六个X。默认的文件名模板是tmp.后接十个随机字符。 $ mktemp -t mytemp.XXXXXXX /tmp/mytemp.yZ1HgZV 4. trap 命令 trap命令用来在 Bash 脚本中响应系统信号。 最常见的系统信号就是 SIGINT（中断），即按 Ctrl + C 所产生的信号。trap命令的-l参数，可以列出所有的系统信号。 $ trap -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX trap的命令格式如下。 $ trap [动作] [信号1] [信号2] ... 上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。 HUP：编号1，脚本与所在的终端脱离联系。 INT：编号2，用户按下 Ctrl + C，意图让脚本终止运行。 QUIT：编号3，用户按下 Ctrl + 斜杠，意图退出脚本。 KILL：编号9，该信号用于杀死进程。 TERM：编号15，这是kill命令发出的默认信号。 EXIT：编号0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。 trap命令响应EXIT信号的写法如下。 $ trap 'rm -f \"$TMPFILE\"' EXIT 上面命令中，脚本遇到EXIT信号时，就会执行rm -f \"$TMPFILE\"。 trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。 #!/bin/bash trap 'rm -f \"$TMPFILE\"' EXIT TMPFILE=$(mktemp) || exit 1 ls /etc > $TMPFILE if grep -qi \"kernel\" $TMPFILE; then echo 'find' fi 上面代码中，不管是脚本正常执行结束，还是用户按 Ctrl + C 终止，都会产生EXIT信号，从而触发删除临时文件。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] trap命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。 如果trap需要触发多条命令，可以封装一个 Bash 函数。 function egress { command1 command2 command3 } trap egress EXIT 参考: 阮一峰老师的mktemp 命令，trap 命令 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-28 08:28:12 "},"Base/shell_command_sleep.html":{"url":"Base/shell_command_sleep.html","title":"shell sleep 睡眠","keywords":"","body":"shell sleep 睡眠1. 背景2. 简介3. 语法4. 实例4.1 设置警报4.2 终端中的延迟命令4.3 将变量分配给 sleep 命令4.4 定义检查间隔4.5 为操作完成留出时间4.6 预测延迟5 总结shell sleep 睡眠 1. 背景 当用户在 Linux 中发出多个命令序列时，命令会立即一个接一个或同时执行（例如，tee 命令）。但是，有时需要推迟命令的执行并为系统提供足够的时间来产生预期的结果。 2. 简介 sleep命令将下一个命令的调用进程挂起一段指定的时间。当以下命令的执行取决于前一个命令的成功完成时，此属性很有用。 3. 语法 sleep [number] 在上面的示例中， aftersleep 5执行后，第二个命令提示符出现了 5 秒的延迟。 默认情况下，系统读取之后sleep的数字作为秒数。要指定其他时间单位，请使用以下语法： sleep [number][unit] 该sleep命令接受浮点数。它允许多个值相加，以计算sleep. 可用单位有： s– 秒 m- 分钟 h- 小时 d- 天 要sleep在开始后和指定的等待时间结束前停止，请按Ctrl + C。 要查看该sleep命令的帮助，请键入： sleep --help 有关版本详细信息，请键入： sleep --version 4. 实例 4.1 设置警报 用于sleep告诉系统在一定时间后播放 mp3 文件。该示例使用 mplayer： sleep 7h 30m && mplayer alarm.mp3 4.2 终端中的延迟命令 sleep对于强制执行两个命令之间的时间很有用。以下示例使echo命令以一秒的间隔执行： sleep 1 && echo \"one\" && sleep 1 && echo \"two\" 4.3 将变量分配给 sleep 命令 可以将变量分配给sleep命令。考虑以下 shell 脚本： #!/bin/bash SLEEP_INTERVAL=\"30\" CURRENT_TIME=$(date +\"%T\") echo \"Time before sleep: ${CURRENT_TIME}\" echo \"Sleeping for ${SLEEP_INTERVAL} seconds\" sleep ${SLEEP_INTERVAL} CURRENT_TIME=$(date +\"%T\") echo \"Time after sleep: ${CURRENT_TIME}\" 该脚本定义了一个名为的变量SLEEP_INTERVAL ，其值稍后用作sleep命令的参数。此示例脚本的输出显示执行持续了 30 秒： 4.4 定义检查间隔 以下示例说明了sleep在检查网站是否在线的脚本中使用该命令。如果成功 ping 一个网站，脚本就会停止，并sleep在不成功的 ping 之间引入 10 秒的延迟。 #!/bin/bash while : do if ping -c 1 www.google.com &> /dev/null then echo \"Google is online\" break fi sleep 10 done 4.5 为操作完成留出时间 您可能正在运行一个 bash 脚本，该脚本在内部调用另外两个 bash 脚本——一个在后台运行测试，另一个打印结果。如果第二个脚本在第一个脚本完成之前执行，用于sleep防止第二个脚本打印错误的结果： while kill -0 $BACK_PID ; do echo \"Waiting for the process to end\" sleep 1 done 该kill -0 $BACK_PID命令检查第一个脚本的进程是否仍在运行。如果是，它会打印消息并休眠 1 秒钟，然后再次检查。 4.6 预测延迟 用于sleep允许某些命令执行的延迟。下面的脚本片段显示了如何sleep在下一次迭代之前给 CPU 足够的时间来执行计算。 for (( i = 1 ; i 5 总结 bash wait 命令是一个Shell 命令，它等待后台运行的进程完成并返回退出状态。与等待指定时间的 sleep 命令不同，wait 命令等待所有或特定的后台任务完成。 参考： How to Use the Linux sleep Command with Examples Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-10-16 08:22:28 "},"Base/shell_multithread_script.html":{"url":"Base/shell_multithread_script.html","title":"shell 多线程脚本","keywords":"","body":"Shell 多线程脚本1. 千台主机ping是否连通2. 网站健康状态检查Shell 多线程脚本 1. 千台主机ping是否连通 #!/bin/sh #文本分割函数：将文本$1按份数$2进行分割 SplitFile() { linenum=`wc -l $1 |awk '{print $1}'` if [[ $linenum -le $2 ]] then echo \"The lines of this file is less then $2, Are you kidding me...\" exit fi Split=`expr $linenum / $2` Num1=1 FileNum=1 test -d SplitFile || mkdir -p SplitFile rm -rf SplitFile/* while [ $Num1 -lt $linenum ] do Num2=`expr $Num1 + $Split` sed -n \"${Num1}, ${Num2}p \" $1 > SplitFile/$1-$FileNum Num1=`expr $Num2 + 1` FileNum=`expr $FileNum + 1` done } #Define some variables SPLIT_NUM=${1:-10} #参数1表示分割成多少份即,开启多少个线程，默认10个 FILE=${2:-iplist} #参数2表示分割的对象，默认iplist文件 #分割文件 SplitFile $FILE $SPLIT_NUM #循环遍历临时IP文件 for iplist in $(ls ./SplitFile/*) do #循环ping测试临时IP文件中的ip（丢后台） cat $iplist | while read ip do ping -c 4 -w 4 $ip >/dev/null && echo $ip | tee -ai okip.log #ping 可达的IP则写入日志 done & #在while循环后面加上&符号，让这个嵌套循环在后台执行 done 执行 $ bash ping.sh 3 ip_list 2. 网站健康状态检查 抓出中国博客联盟失联站点 #!/bin/bash #Author:ZhangGe #Date：2014-08-21 #Desc：Check the site of ZGboke Alliance. #取出网站数据 data=`/usr/bin/mysql -uroot -p123456 -e \"use zgboke;select web_url from dir_websites where web_status='3';\" -N -B | awk '{print $1}'` if [ -z \"$data\" ];then echo \"Faild to connect database!\" exit 1 fi test -f result.log && rm -f result.log function delay { sleep 3 } tmp_fifofile=/tmp/$$.fifo mkfifo $tmp_fifofile exec 6<>$tmp_fifofile rm $tmp_fifofile #定义并发线程数，需根据vps配置进行调整。 thread=100 for ((i=0 ;i&6 #开始多线程循环检测 for url in $data do read -u6 { #curl抓取网站http状态码 code=`curl -o /dev/null --retry 3 --retry-max-time 8 -s -w %{http_code} $url` echo \"$code ---> $url\">>result.log #判断子线程是否执行成功，并输出结果 delay && { echo \"$code ---> $url\" } || { echo \"Check thread error!\" } echo >& 6 }& done #等待所有线程执行完毕 wait exec 6>&- #找出非200返回码的站点 echo List of exception website: cat result.log | grep -v 200 exit 0 参考： 张戈分享一个入门级可控多线程shell脚本方案 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 06:07:50 "},"Base/shell_array.html":{"url":"Base/shell_array.html","title":"shell 数组","keywords":"","body":"Shell 数组1. 简介2. 创建数组3. 读取数组3.1 读取单个元素3.2 读取所有元素4 默认位置5. 获取数组的长度6. 提取数组序号7. 提取数组成员8. 追加数组成员9. 删除数组10. 关联数组Shell 数组 @[toc] 1. 简介 数组中可以存放多个值。Bash Shell 只支持一维数组（不支持多维数组），初始化时不需要定义数组大小（与 PHP 类似）。 与大部分编程语言类似，数组元素的下标由 0 开始。 Shell 数组用括号来表示，元素用\"空格\"符号分割开，语法格式如下： array_name=(value1 value2 ... valuen) 2. 创建数组 my_array=(A B \"C\" D) array_name[0]=value0 array_name[1]=value1 array_name[2]=value2 一次性赋值 ARRAY=(value1 value2 ... valueN) # 等同于 ARRAY=( value1 value2 value3 ) 也可以指定位置赋值 $ array=(a b c) $ array=([2]=c [0]=a [1]=b) $ days=(Sun Mon Tue Wed Thu Fri Sat) $ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat) 单独某些位置指定也可以。 names=(hatter [5]=duchess alice) 上面例子中，hatter是数组的0号位置，duchess是5号位置，alice是6号位置。 没有赋值的数组元素的默认值是空字符串。 定义数组的时候，可以使用通配符。 $ mp3s=( *.mp3 ) 上面例子中，将当前目录的所有 MP3 文件，放进一个数组。 先用declare -a命令声明一个数组，也是可以的。 $ declare -a ARRAYNAME read -a命令则是将用户的命令行输入，存入一个数组。 $ read -a dice 上面命令将用户的命令行输入，存入数组dice。 3. 读取数组 3.1 读取单个元素 #!/bin/bash my_array=(A B \"C\" D) echo \"第一个元素为: ${my_array[0]}\" echo \"第二个元素为: ${my_array[1]}\" echo \"第三个元素为: ${my_array[2]}\" echo \"第四个元素为: ${my_array[3]}\" 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 第一个元素为: A 第二个元素为: B 第三个元素为: C 第四个元素为: D 3.2 读取所有元素 使用@ 或 * 可以获取数组中的所有元素，例如： #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \"数组的元素为: ${my_array[*]}\" echo \"数组的元素为: ${my_array[@]}\" 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 数组的元素为: A B C D 数组的元素为: A B C D for循环遍历 foo=(a b c d e f) for i in \"${foo[@]}\"; do echo $i done @和*放不放在双引号之中，是有差别的。 $ activities=( swimming \"water skiing\" canoeing \"white-water rafting\" surfing ) $ for act in ${activities[@]}; \\ do \\ echo \"Activity: $act\"; \\ done Activity: swimming Activity: water Activity: skiing Activity: canoeing Activity: white-water Activity: rafting Activity: surfing 上面的例子中，数组activities实际包含5个成员，但是for...in循环直接遍历${activities[@]}，导致返回7个结果。为了避免这种情况，一般把${activities[@]}放在双引号之中。 $ for act in \"${activities[@]}\"; \\ do \\ echo \"Activity: $act\"; \\ done Activity: swimming Activity: water skiing Activity: canoeing Activity: white-water rafting Activity: surfing 上面例子中，${activities[@]}放在双引号之中，遍历就会返回正确的结果。 ${activities[*]}不放在双引号之中，跟${activities[@]}不放在双引号之中是一样的。 $ for act in ${activities[*]}; \\ do \\ echo \"Activity: $act\"; \\ done Activity: swimming Activity: water Activity: skiing Activity: canoeing Activity: white-water Activity: rafting Activity: surfing ${activities[*]}放在双引号之中，所有成员就会变成单个字符串返回。 $ for act in \"${activities[*]}\"; \\ do \\ echo \"Activity: $act\"; \\ done Activity: swimming water skiing canoeing white-water rafting surfing 所以，拷贝一个数组的最方便方法，就是写成下面这样。 $ hobbies=( \"${activities[@]}\" ) 上面例子中，数组activities被拷贝给了另一个数组hobbies。 这种写法也可以用来为新数组添加成员。 $ hobbies=( \"${activities[@]}\" diving ) 上面例子中，新数组hobbies在数组activities的所有成员之后，又添加了一个成员。 4 默认位置 如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用0号位置。 $ declare -a foo $ foo=A $ echo ${foo[0]} A 上面例子中，foo是一个数组，赋值的时候不指定位置，实际上是给foo[0]赋值。 引用一个不带下标的数组变量，则引用的是0号位置的数组元素。 $ foo=(a b c d e f) $ echo ${foo} a $ echo $foo a 上面例子中，引用数组元素的时候，没有指定位置，结果返回的是0号位置。 5. 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： #!/bin/bash my_array[0]=A my_array[1]=B my_array[2]=C my_array[3]=D echo \"数组元素个数为: ${#my_array[*]}\" echo \"数组元素个数为: ${#my_array[@]}\" 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 数组元素个数为: 4 数组元素个数为: 4 当读取具体数组成员 $ a[100]=foo $ echo ${#a[*]} 1 $ echo ${#a[@]} 1 上面例子中，把字符串赋值给100位置的数组元素，这时的数组只有一个元素。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。 $ a[100]=foo $ echo ${#a[100]} 3 上面例子中，${#a[100]}实际上是返回数组第100号成员a[100]的值（foo）的字符串长度。 6. 提取数组序号 ${!array[@]}或${!array[*]}，可以返回数组的成员序号，即哪些位置是有值的。 $ arr=([5]=a [9]=b [23]=c) $ echo ${!arr[@]} 5 9 23 $ echo ${!arr[*]} 5 9 23 上面例子中，数组的5、9、23号位置有值。 利用这个语法，也可以通过for循环遍历数组。 arr=(a b c d) for i in ${!arr[@]};do echo ${arr[i]} done 7. 提取数组成员 ${array[@]:position:length}的语法可以提取数组成员。 $ food=( apples bananas cucumbers dates eggs fajitas grapes ) $ echo ${food[@]:1:1} bananas $ echo ${food[@]:1:3} bananas cucumbers dates 上面例子中，${food[@]:1:1}返回从数组1号位置开始的1个成员，${food[@]:1:3}返回从1号位置开始的3个成员。 如果省略长度参数length，则返回从指定位置开始的所有成员。 $ echo ${food[@]:4} eggs fajitas grapes 上面例子返回从4号位置开始到结束的所有成员。 8. 追加数组成员 数组末尾追加成员，可以使用+=赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。 $ foo=(a b c) $ echo ${foo[@]} a b c $ foo+=(d e f) $ echo ${foo[@]} a b c d e f 9. 删除数组 删除一个数组成员，使用unset命令。 $ foo=(a b c d e f) $ echo ${foo[@]} a b c d e f $ unset foo[2] $ echo ${foo[@]} a b d e f 上面例子中，删除了数组中的第三个元素，下标为2。 将某个成员设为空值，可以从返回值中“隐藏”这个成员。 $ foo=(a b c d e f) $ foo[1]='' $ echo ${foo[@]} a c d e f 上面例子中，将数组的第二个成员设为空字符串，数组的返回值中，这个成员就“隐藏”了。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 这里是“隐藏”，而不是删除，因为这个成员仍然存在，只是值变成了空值。 $ foo=(a b c d e f) $ foo[1]='' $ echo ${#foo[@]} 6 $ echo ${!foo[@]} 0 1 2 3 4 5 上面代码中，第二个成员设为空值后，数组仍然包含6个成员。 由于空值就是空字符串，所以下面这样写也有隐藏效果，但是不建议这种写法。 $ foo[1]= 上面的写法也相当于“隐藏”了数组的第二个成员。 直接将数组变量赋值为空字符串，相当于“隐藏”数组的第一个成员。 $ foo=(a b c d e f) $ foo='' $ echo ${foo[@]} b c d e f 上面的写法相当于“隐藏”了数组的第一个成员。 unset ArrayName可以清空整个数组。 $ unset ARRAY $ echo ${ARRAY[*]} 10. 关联数组 Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。 declare -A可以声明关联数组。 declare -A colors colors[\"red\"]=\"#ff0000\" colors[\"green\"]=\"#00ff00\" colors[\"blue\"]=\"#0000ff\" 关联数组必须用带有-A选项的declare命令声明创建。相比之下，整数索引的数组，可以直接使用变量名创建数组，关联数组就不行。 访问关联数组成员的方式，几乎与整数索引数组相同。 echo ${colors[\"blue\"]} 参考： Unix / Linux - Using Shell Arrays Arrays in unix shell? Array Basics in Shell Scripting | Set 1 阮一峰老师的bash 数组 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-28 09:12:44 "},"Base/shell_Cross-script_variable_declaration.html":{"url":"Base/shell_Cross-script_variable_declaration.html","title":"shell 跨脚本变量传递","keywords":"","body":"shell 跨脚本变量传递1. source2 exportshell 跨脚本变量传递 1. source 当前脚本调用另一个脚本变量 $ cat test1.sh #!/bin/bash a=Hello World echo \"test1:$a\" $ cat test2.sh #!/bin/bash /root/test1.sh echo \" test2:$a\" [root@centos ~]# sh test2.sh test1:Hello World test2: 从结果可以看出test1.sh没有把变量a的值传递给test2.sh 我们把test2.sh改成： #!/bin/bash source /root/test1.sh echo \"test2:$a\" [root@centos ~]# sh test2.sh test1:Hello World test2:Hello World 2 export 当前脚本（第二者脚本）中执行第三者脚本用到第一者脚本中的变量 $ cat test3.sh #!/bin/bash echo \"test3:$a\" 把test2.sh改成： #!/bin/bash source /root/test1.sh echo \"test2:$a\" /root/test3.sh 执行test2.sh： [root@shenji ~]# sh test2.sh test1:Hello World test2:Hello World test3: 将test1.sh改成： #!/bin/bash export a=Hello World echo \"test1:$a\" 执行test2.sh后有如下结果： $ sh test2.sh test1:Hello World test2:Hello World test3:Hello World Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 04:53:31 "},"Base/shell_help.html":{"url":"Base/shell_help.html","title":"shell 查看帮助","keywords":"","body":"Shell 查看帮助12Shell 查看帮助 Shell 脚本添加查看帮助，让他人更容易看懂理解。 1 help() { header echo echo 'Usage: cckiller [OPTIONS] [N]' echo 'N : number of tcp/udp connections (default 100)' echo echo 'OPTIONS:' echo \"-h | --help: Show this help screen\" echo \"-k | --kill: Block the offending ip making more than N connections\" echo '-s | --show: Show The TOP \"N\" Connections of System Current' echo \"-b | --banip: Ban The IP or IP subnet like cckiller -b 192.168.1.1\" echo \"-u | --unban: Unban The IP or IP subnet which is in the BlackList of iptables\" echo } if [ $# -lt 2 ]; then help fi 2 # Notes: # - Please install \"jq\" package before using this driver. usage() { err \"Invalid usage. Usage: \" err \"\\t$0 init\" err \"\\t$0 mount \" err \"\\t$0 unmount \" exit 1 } err() { echo -ne $* 1>&2 } ... if [ $# -lt 2 ]; then usage fi .... Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 07:12:35 "},"Base/shell_operator.html":{"url":"Base/shell_operator.html","title":"shell 运算符","keywords":"","body":"Shell 运算符1. 基本运算符2. 算数运算符3. 关系运算符4. 布尔运算符5. 逻辑运算符6. 字符串运算符7. 文件测试运算符Shell 运算符 1. 基本运算符 Shell 和其他编程语言一样，支持多种运算符，包括： 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 2. 算数运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 例如，两个数相加(注意使用的是反引号 ` 而不是单引号 ‘)： #!/bin/bash val=`expr 2 + 2` echo \"两数之和为 : $val\" 执行脚本，输出结果如下所示： 两数之和为 : 4 两点注意 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算术运算符 下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 +加法 expr $a + $b 结果为 30。 –减法 expr $a – $b 结果为 -10。 乘法 `expr $a \\ $b` 结果为 200。 / 除法 expr $b / $a 结果为 2。 %取余 expr $b % $a 结果为 0。 =赋值 a=$b 将把变量 b 的值赋给 a。 ==相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 !=不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 实例 算术运算符实例如下： #!/bin/bash a=10 b=20 val=`expr $a + $b` echo \"a + b : $val\" val=`expr $a - $b` echo \"a - b : $val\" val=`expr $a \\* $b` echo \"a * b : $val\" val=`expr $b / $a` echo \"b / a : $val\" val=`expr $b % $a` echo \"b % a : $val\" if [ $a == $b ] then echo \"a 等于 b\" fi if [ $a != $b ] then echo \"a 不等于 b\" fi 执行脚本，输出结果如下所示： a + b : 30 a - b : -10 a * b : 200 b / a : 2 b % a : 0 a 不等于 b 注意： 乘号(*)前边必须加反斜杠()才能实现乘法运算； 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “\\” 。 递增加法： 1. i=`expr $i + 1` 2. let i+=1 3. ((i++)) 4. i=$[$i+1] 5. i=$(( $i + 1 )) 3. 关系运算符 关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 实例 关系运算符实例如下： #!/bin/bash a=10 b=20 if [ $a -eq $b ] then echo \"$a -eq $b : a 等于 b\" else echo \"$a -eq $b: a 不等于 b\" fi if [ $a -ne $b ] then echo \"$a -ne $b: a 不等于 b\" else echo \"$a -ne $b : a 等于 b\" fi if [ $a -gt $b ] then echo \"$a -gt $b: a 大于 b\" else echo \"$a -gt $b: a 不大于 b\" fi if [ $a -lt $b ] then echo \"$a -lt $b: a 小于 b\" else echo \"$a -lt $b: a 不小于 b\" fi if [ $a -ge $b ] then echo \"$a -ge $b: a 大于或等于 b\" else echo \"$a -ge $b: a 小于 b\" fi if [ $a -le $b ] then echo \"$a -le $b: a 小于或等于 b\" else echo \"$a -le $b: a 大于 b\" fi 执行脚本，输出结果如下所示： 10 -eq 20: a 不等于 b 10 -ne 20: a 不等于 b 10 -gt 20: a 不大于 b 10 -lt 20: a 小于 b 10 -ge 20: a 小于 b 10 -le 20: a 小于或等于 b 4. 布尔运算符 下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20： 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 实例 布尔运算符实例如下： #!/bin/bash a=10 b=20 if [ $a != $b ] then echo \"$a != $b : a 不等于 b\" else echo \"$a != $b: a 等于 b\" fi if [ $a -lt 100 -a $b -gt 15 ] then echo \"$a -lt 100 -a $b -gt 15 : 返回 true\" else echo \"$a -lt 100 -a $b -gt 15 : 返回 false\" fi if [ $a -lt 100 -o $b -gt 100 ] then echo \"$a -lt 100 -o $b -gt 100 : 返回 true\" else echo \"$a -lt 100 -o $b -gt 100 : 返回 false\" fi if [ $a -lt 5 -o $b -gt 100 ] then echo \"$a -lt 100 -o $b -gt 100 : 返回 true\" else echo \"$a -lt 100 -o $b -gt 100 : 返回 false\" fi 执行脚本，输出结果如下所示： 10 != 20 : a 不等于 b 10 -lt 100 -a 20 -gt 15 : 返回 true 10 -lt 100 -o 20 -gt 100 : 返回 true 10 -lt 100 -o 20 -gt 100 : 返回 false 5. 逻辑运算符 以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20: 运算符 说明 举例 && 逻辑的 AND [[ $a -lt 100 && $b -gt 100 ]] 返回 false || 逻辑的 OR [[ $a -lt 100 || $b -gt 100 ]] 返回 true 实例 逻辑运算符实例如下： #!/bin/bash a=10 b=20 if [[ $a -lt 100 && $b -gt 100 ]] then echo \"返回 true\" else echo \"返回 false\" fi if [[ $a -lt 100 || $b -gt 100 ]] then echo \"返回 true\" else echo \"返回 false\" fi 执行脚本，输出结果如下所示： 返回 false 返回 true 6. 字符串运算符 下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”： 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 实例 字符串运算符实例如下： #!/bin/bash a=\"abc\" b=\"efg\" if [ $a = $b ] then echo \"$a = $b : a 等于 b\" else echo \"$a = $b: a 不等于 b\" fi if [ $a != $b ] then echo \"$a != $b : a 不等于 b\" else echo \"$a != $b: a 等于 b\" fi if [ -z $a ] then echo \"-z $a : 字符串长度为 0\" else echo \"-z $a : 字符串长度不为 0\" fi if [ -n $a ] then echo \"-n $a : 字符串长度不为 0\" else echo \"-n $a : 字符串长度为 0\" fi if [ $a ] then echo \"$a : 字符串不为空\" else echo \"$a : 字符串为空\" fi 执行脚本，输出结果如下所示： abc = efg: a 不等于 b abc != efg : a 不等于 b -z abc : 字符串长度不为 0 -n abc : 字符串长度不为 0 abc : 字符串不为空 7. 文件测试运算符 文件测试运算符用于检测 Unix 文件的各种属性。 属性检测描述如下： 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 实例 变量 file 表示文件”/var/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性： #!/bin/bash file=\"/var/test.sh\" if [ -r $file ] then echo \"文件可读\" else echo \"文件不可读\" fi if [ -w $file ] then echo \"文件可写\" else echo \"文件不可写\" fi if [ -x $file ] then echo \"文件可执行\" else echo \"文件不可执行\" fi if [ -f $file ] then echo \"文件为普通文件\" else echo \"文件为特殊文件\" fi if [ -d $file ] then echo \"文件是个目录\" else echo \"文件不是个目录\" fi if [ -s $file ] then echo \"文件不为空\" else echo \"文件为空\" fi if [ -e $file ] then echo \"文件存在\" else echo \"文件不存在\" fi 执行脚本，输出结果如下所示： 文件可读 文件可写 文件可执行 文件为普通文件 文件不是个目录 文件不为空 文件存在 参考： Unix / Linux - Shell Basic Operators Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-15 12:00:04 "},"Base/shell_variable.html":{"url":"Base/shell_variable.html","title":"shell 变量","keywords":"","body":"Shell 变量1. 简介1.1 环境变量1.2 自定义变量2. 创建变量3. 读取变量4. 删除变量5. 输出变量，export 命令6. 特殊变量6.1 $?6.2 $$6.3 $_6.4 $!6.5 $06.6 $-6.7 $@和$#7. 变量的默认值8. declare 命令8.1 -i 参数8.2 -x 参数8.3 -r 参数8.4 -u 参数8.5 -l 参数8.6 -p 参数8.7 -f 参数8.8 -F 参数9. readonly 命令10. let 命令Shell 变量 1. 简介 Bash 变量分成环境变量和自定义变量两类。 1.1 环境变量 环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。 env命令或printenv命令，可以显示所有环境变量。 $ env # 或者 $ printenv 下面是一些常见的环境变量。 BASHPID：Bash 进程的进程 ID。 BASHOPTS：当前 Shell 的参数，可以用shopt命令修改。 DISPLAY：图形环境的显示器名字，通常是:0，表示 X Server 的第一个显示器。 EDITOR：默认的文本编辑器。 HOME：用户的主目录。 HOST：当前主机的名称。 IFS：词与词之间的分隔符，默认为空格。 LANG：字符集以及语言编码，比如zh_CN.UTF-8。 PATH：由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。 PS1：Shell 提示符。 PS2： 输入多行命令时，次要的 Shell 提示符。 PWD：当前工作目录。 RANDOM：返回一个0到32767之间的随机数。 SHELL：Shell 的名字。 SHELLOPTS：启动当前 Shell 的set命令的参数 TERM：终端类型名，即终端仿真器所用的协议。 UID：当前用户的 ID 编号。 USER：当前用户的用户名。 很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] Bash 变量名区分大小写，HOME和home是两个不同的变量。 查看单个环境变量的值，可以使用printenv命令或echo命令。 $ printenv PATH # 或者 $ echo $PATH [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] printenv命令后面的变量名，不用加前缀$。 1.2 自定义变量 自定义变量是用户在当前 Shell 里面自己定义的变量，仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。 set命令可以显示所有变量（包括环境变量和自定义变量），以及所有的 Bash 函数。 $ set 2. 创建变量 用户创建变量的时候，变量名必须遵守下面的规则。 字母、数字和下划线字符组成。 第一个字符必须是一个字母或一个下划线，不能是数字。 不允许出现空格和标点符号。 变量声明的语法如下。 variable=value 上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。 如果变量的值包含空格，则必须将值放在引号中。 myvar=\"hello world\" Bash 没有数据类型的概念，所有的变量值都是字符串。 下面是一些自定义变量的例子。 a=z # 变量 a 赋值为字符串 z b=\"a string\" # 变量值包含空格，就必须放在引号里面 c=\"a string and $b\" # 变量值可以引用其他变量的值 d=\"\\t\\ta string\\n\" # 变量值可以使用转义字符 e=$(ls -l foo.txt) # 变量值可以是命令的执行结果 f=$((5 * 7)) # 变量值可以是数学运算的结果 变量可以重复赋值，后面的赋值会覆盖前面的赋值。 $ foo=1 $ foo=2 $ echo $foo 2 上面例子中，变量foo的第二次赋值会覆盖第一次赋值。 如果同一行定义多个变量，必须使用分号（;）分隔。 $ foo=1;bar=2 上面例子中，同一行定义了foo和bar两个变量。 3. 读取变量 读取变量的时候，直接在变量名前加上$就可以了。 $ foo=bar $ echo $foo bar 每当 Shell 看到以$开头的单词时，就会尝试读取这个变量名对应的值。 如果变量不存在，Bash 不会报错，而会输出空字符。 由于$在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心， $ echo The total is $100.00 The total is 00.00 上面命令的原意是输入$100，但是 Bash 将$1解释成了变量，该变量为空，因此输入就变成了00.00。所以，如果要使用$的原义，需要在$前面放上反斜杠，进行转义。 $ echo The total is \\$100.00 The total is $100.00 读取变量的时候，变量名也可以使用花括号{}包围，比如$a也可以写成${a}。这种写法可以用于变量名与其他字符连用的情况。 $ a=foo $ echo $a_file $ echo ${a}_file foo_file 上面代码中，变量名a_file不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分$a，Bash 才能正确解读。 事实上，读取变量的语法$foo，可以看作是${foo}的简写形式。 如果变量的值本身也是变量，可以使用${!varname}的语法，读取最终的值。 $ myvar=USER $ echo ${!myvar} ruanyf 上面的例子中，变量myvar的值是USER，${!myvar}的写法将其展开成最终的值。 如果变量值包含连续空格（或制表符和换行符），最好放在双引号里面读取。 $ a=\"1 2 3\" $ echo $a 1 2 3 $ echo \"$a\" 1 2 3 上面示例中，变量a的值包含两个连续空格。如果直接读取，Shell 会将连续空格合并成一个。只有放在双引号里面读取，才能保持原来的格式。 4. 删除变量 unset命令用来删除一个变量。 unset NAME 这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使unset命令删除了变量，还是可以读取这个变量，值为空字符串。 所以，删除一个变量，也可以将这个变量设成空字符串。 $ foo='' $ foo= 上面两种写法，都是删除了变量foo。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。 5. 输出变量，export 命令 用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用export命令。这样输出的变量，对于子 Shell 来说就是环境变量。 export命令用来向子 Shell 输出变量。 NAME=foo export NAME 上面命令输出了变量NAME。变量的赋值和输出也可以在一个步骤中完成。 export NAME=value 上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量$NAME。 子 Shell 如果修改继承的变量，不会影响父 Shell。 # 输出变量 $foo $ export foo=bar # 新建子 Shell $ bash # 读取 $foo $ echo $foo bar # 修改继承的变量 $ foo=baz # 退出子 Shell $ exit # 读取 $foo $ echo $foo bar 上面例子中，子 Shell 修改了继承的变量$foo，对父 Shell 没有影响。 6. 特殊变量 Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。 6.1 $? $?为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是0，表示上一个命令执行成功；如果不是零，表示上一个命令执行失败。 $ ls doesnotexist ls: doesnotexist: No such file or directory $ echo $? 1 上面例子中，ls命令查看一个不存在的文件，导致报错。$?为1，表示上一个命令执行失败。 6.2 $$ $$为当前 Shell 的进程 ID。 $ echo $$ 10662 这个特殊变量可以用来命名临时文件。 LOGFILE=/tmp/output_log.$$ 6.3 $_ $_为上一个命令的最后一个参数。 $ grep dictionary /usr/share/dict/words dictionary $ echo $_ /usr/share/dict/words 6.4 $! $!为最近一个后台执行的异步命令的进程 ID。 $ firefox & [1] 11064 $ echo $! 11064 上面例子中，firefox是后台运行的命令，$!返回该命令的进程 ID。 6.5 $0 $0为当前 Shell 的名称（在命令行直接执行时）或者脚本名（在脚本中执行时）。 $ echo $0 bash 上面例子中，$0返回当前运行的是 Bash。 6.6 $- $-为当前 Shell 的启动参数。 $ echo $- himBHs 6.7 $@和$# $#表示脚本的参数数量，$@表示脚本的参数值 7. 变量的默认值 Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。 ${varname:-word} 上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则返回word。它的目的是返回一个默认值，比如${count:-0}表示变量count不存在时返回0。 ${varname:=word} 上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则将它设为word，并且返回word。它的目的是设置变量的默认值，比如${count:=0}表示变量count不存在时返回0，且将count设为0。 ${varname:+word} 上面语法的含义是，如果变量名存在且不为空，则返回word，否则返回空值。它的目的是测试变量是否存在，比如${count:+1}表示变量count存在时返回1（表示true），否则返回空值。 ${varname:?message} 上面语法的含义是，如果变量varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行。如果省略了message，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如${count:?\"undefined!\"}表示变量count未定义时就中断执行，抛出错误，返回给定的报错信息undefined!。 上面四种语法如果用在脚本中，变量名的部分可以用数字1到9，表示脚本的参数。 filename=${1:?\"filename missing.\"} 上面代码出现在脚本中，1表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。 8. declare 命令 declare命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。 它的语法形式如下。 declare OPTION VARIABLE=value declare命令的主要参数（OPTION）如下。 -a：声明数组变量。 -f：输出所有函数定义。 -F：输出所有函数名。 -i：声明整数变量。 -l：声明变量为小写字母。 -p：查看变量信息。 -r：声明只读变量。 -u：声明变量为大写字母。 -x：该变量输出为环境变量。 declare 命令如果用在函数中，声明的变量只在函数内部有效，等同于local命令。 不带任何参数时，declare命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的set命令。 $ declare 8.1 -i 参数 -i参数声明整数变量以后，可以直接进行数学运算。 $ declare -i val1=12 val2=5 $ declare -i result $ result=val1*val2 $ echo $result 60 上面例子中，如果变量result不声明为整数，val1*val2会被当作字面量，不会进行整数运算。另外，val1和val2其实不需要声明为整数，因为只要result声明为整数，它的赋值就会自动解释为整数运算。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] 一个变量声明为整数以后，依然可以被改写为字符串。 $ declare -i var=12 $ var=foo $ echo $var 0 上面例子中，变量var声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出0，也可能输出的是3。 8.2 -x 参数 -x参数等同于export命令，可以输出一个变量为子 Shell 的环境变量。 $ declare -x foo # 等同于 $ export foo 8.3 -r 参数 -r参数可以声明只读变量，无法改变变量值，也不能unset变量。 $ declare -r bar=1 $ bar=2 bash: bar：只读变量 $ echo $? 1 $ unset bar bash: bar：只读变量 $ echo $? 1 上面例子中，后两个赋值语句都会报错，命令执行失败。 8.4 -u 参数 -u参数声明变量为大写字母，可以自动把变量值转成大写字母。 $ declare -u foo $ foo=upper $ echo $foo UPPER 8.5 -l 参数 -l参数声明变量为小写字母，可以自动把变量值转成小写字母。 $ declare -l bar $ bar=LOWER $ echo $bar lower 8.6 -p 参数 -p参数输出变量信息。 $ foo=hello $ declare -p foo declare -- foo=\"hello\" $ declare -p bar bar：未找到 上面例子中，declare -p可以输出已定义变量的值，对于未定义的变量，会提示找不到。 如果不提供变量名，declare -p输出所有变量的信息。 $ declare -p 8.7 -f 参数 -f参数输出当前环境的所有函数，包括它的定义。 $ declare -f 8.8 -F 参数 -F参数输出当前环境的所有函数名，不包含函数定义。 $ declare -F 9. readonly 命令 readonly命令等同于declare -r，用来声明只读变量，不能改变变量值，也不能unset变量。 $ readonly foo=1 $ foo=2 bash: foo：只读变量 $ echo $? 1 上面例子中，更改只读变量foo会报错，命令执行失败。 readonly命令有三个参数。 -f：声明的变量为函数名。 -p：打印出所有的只读变量。 -a：声明的变量为数组。 10. let 命令 let命令声明变量时，可以直接执行算术表达式。 $ let foo=1+2 $ echo $foo 3 上面例子中，let命令可以直接计算1 + 2。 let命令的参数表达式如果包含空格，就需要使用引号。 $ let \"foo = 1 + 2\" let可以同时对多个变量赋值，赋值表达式之间使用空格分隔。 $ let \"v1 = 1\" \"v2 = v1++\" $ echo $v1,$v2 2,1 上面例子中，let声明了两个变量v1和v2，其中v2等于v1++，表示先返回v1的值，然后v1自增。 参考： Bash 变量 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-28 05:23:17 "},"Base/shell_function.html":{"url":"Base/shell_function.html","title":"shell 函数","keywords":"","body":"Shell 函数1. 函数定义2. 函数调用3. 参数传递4. 函数的返回值5. 函数的载入6. 函数利用7. 函数变量作用域8. 函数的嵌套Shell 函数 1. 函数定义 function name() { statements [return value] } 对各个部分的说明： function是 Shell 中的关键字，专门用来定义函数，可以省略； name是函数名； statements是函数要执行的代码，也就是一组语句； return value表示函数的返回值，其中 return 是 Shell 关键字，专门用在函数中返回一个值；这一部分可以写也可以不写。 由{ }包围的部分称为函数体，调用一个函数，实际上就是执行函数体中的代码 2. 函数调用 调用 Shell 函数时可以给它传递参数，也可以不传递。如果不传递参数，直接给出函数名字即可： name 如果传递参数，那么多个参数之间以空格分隔： name param1 param2 param3 不管是哪种形式，函数名字后面都不需要带括号。 和其它编程语言不同的是，Shell 函数在定义时不能指明参数，但是在调用时却可以传递参数，并且给它传递什么参数它就接收什么参数。 Shell 也不限制定义和调用的顺序，你可以将定义放在调用的前面，也可以反过来，将定义放在调用的后面。 实例： #!/bin/bash function show() { echo \"hello , you are calling the function\" } echo \"first time call the function\" show echo \"second time call the function\" show [root@localhost base]$ bash fun1.sh first time call the function hello , you are calling the function second time call the function hello , you are calling the function 3. 参数传递 函数可以通过位置变量传递参数。例如 函数名 参数1 参数2 参数3 参数4 当函数执行时，$1 对应 参数1，其他依次类推。 实例： #!/bin/bash function show() { echo \"hello , you are calling the function $1\" } echo \"first time call the function\" show first echo \"second time call the function\" show second [root@localhost base]$ bash fun2.sh first time call the function hello , you are calling the function first second time call the function hello , you are calling the function second 4. 函数的返回值 函数中的关键字“return”可以放到函数体的任意位置，通常用于返回某些值，Shell在执行到return之后，就停止往下执行，返回到主程序的调用行，return的返回值只能是0~256之间的一个整数，返回值将保存到变量“$?”中。 [root@localhost base]$ cat fun3.sh #!/bin/bash function abc() { RESULT=`expr $1 \\% 2` #表示取余数 if [ \"$RESULT\" != 0 ]; then return 0 else return 1 fi } echo \"Please enter a number who can devide by 2\" read N abc $N case $? in 0) echo \"yes ,it is\" ;; 1) echo \"no ,it isn’t\" ;; esac [root@localhost base]$ bash fun3.sh Please enter a number who can devide by 2 2 no ,it isn’t [root@localhost base]$ bash fun3.sh Please enter a number who can devide by 2 3 yes ,it is 5. 函数的载入 如果函数在另外一个文件中，我们该怎么调用它呢？ 这里就有一个方法。比如 show 函数写在了function.sh里面了，我们就可以用 source 命令 source function.sh #or . function.sh show 6. 函数利用 如果在函数中使用exit命令，可以退出整个脚本，通常情况，函数结束之后会返回调用函数的部分继续执行。 可以使用break语句来中断函数的执行。 declare –f 可以显示定义的函数清单 declare –F 可以只显示定义的函数名 unset –f 可以从Shell内存中删除函数 export –f 将函数输出给Shell 7. 函数变量作用域 默认情况下，变量具有全局作用域，如果想把它设置为局部作用域，可以在其前加入local 例如： local a=\"hello\" 8. 函数的嵌套 function first() { function second() { function third() { echo \"------this is third\" } echo \"this is the second\" third } echo \"this is the first\" second } echo \"start...\" first [root@localhost base]$ bash fun4.sh start... this is the first this is the second ------this is third 参考： Shell入门教程：Shell函数详解 Shell Scripting Tutorial Functions Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 06:03:25 "},"Base/shell_log_and_print.html":{"url":"Base/shell_log_and_print.html","title":"shell 日志与打印输出","keywords":"","body":"1Shell 日志与打印输出 良好的 shell 脚本从记录日志内容，规范日志格式开始。 1 write_log() { LOG_FILE=$LOGDIR/cckiller_$(date +%Y-%m-%d).log logout=\"\" for((i=2;i Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 06:35:33 "},"Case/":{"url":"Case/","title":"Case","keywords":"","body":"Shell 实例Shell 实例 我会尝试收集有趣、应用、学习、艺术等充满点子的 shell 脚本。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-16 08:30:36 "},"Case/Monitor/":{"url":"Case/Monitor/","title":"Monitor","keywords":"","body":"Shell 监控采集Shell 监控采集 在你平凡的一天工作中，或许你熟悉一些 linux 监控命令工具，但我们有时还需要写一些shell脚本来满足输出。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:44:10 "},"Case/Monitor/shell_fileOrdir_state.html":{"url":"Case/Monitor/shell_fileOrdir_state.html","title":"shell 判断文件 目录状态","keywords":"","body":"Shell 判断文件/目录状态Shell 判断文件/目录状态 tagsstart 监控 tagsstop test-file.sh #!/bin/bash # test-file: Evaluate the status of a file echo \"Hey what's the File/Directory name (using the absolute path)?\" read FILE if [ -e \"$FILE\" ]; then if [ -f \"$FILE\" ]; then echo \"$FILE is a regular file.\" fi if [ -d \"$FILE\" ]; then echo \"$FILE is a directory.\" fi if [ -r \"$FILE\" ]; then echo \"$FILE is readable.\" fi if [ -w \"$FILE\" ]; then echo \"$FILE is writable.\" fi if [ -x \"$FILE\" ]; then echo \"$FILE is executable/searchable.\" fi else echo \"$FILE does not exist\" exit 1 fi exit 执行： $ ls test dirname $ bash test-file.sh Hey what's the File/Directory name (using the absolute path)? test test is a regular file. test is readable. test is writable. $ bash test-file.sh Hey what's the File/Directory name (using the absolute path)? dirname dirname is a directory. dirname is readable. dirname is writable. dirname is executable/searchable. Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:47:53 "},"Case/Monitor/shell_os_message2.html":{"url":"Case/Monitor/shell_os_message2.html","title":"shell 报告服务器信息","keywords":"","body":"Shell 报告服务器信息Shell 报告服务器信息 tagsstart 监控 tagsstop server-health.sh #!/bin/bash date echo \"uptime:\" uptime echo \"Currently connected:\" w echo \"--------------------\" echo \"Last logins:\" last -a | head -3 echo \"--------------------\" echo \"Disk and memory usage:\" df -h | xargs | awk '{print \"Free/total disk: \" $11 \" / \" $9}' free -m | xargs | awk '{print \"Free/total memory: \" $17 \" / \" $8 \" MB\"}' echo \"--------------------\" start_log=$(head -1 /var/log/messages | cut -c 1-12) oom=$(grep -ci kill /var/log/messages) echo -n \"OOM errors since $start_log :\" $oom echo \"\" echo \"--------------------\" echo \"Utilization and most expensive processes:\" top -b | head -3 echo top -b | head -10 | tail -4 echo \"--------------------\" echo \"Open TCP ports:\" nmap -p -T4 127.0.0.1 echo \"--------------------\" echo \"Current connections:\" ss -s echo \"--------------------\" echo \"processes:\" ps auxf --width=200 echo \"--------------------\" echo \"vmstat:\" vmstat 1 5 执行： $ bash server-health.sh Tue Jun 7 16:12:17 UTC 2022 uptime: 16:12:17 up 1 day, 20:24, 2 users, load average: 1.61, 1.61, 1.63 Currently connected: 16:12:17 up 1 day, 20:24, 2 users, load average: 1.61, 1.61, 1.63 USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT root tty1 - Mon15 24:26m 0.66s 0.03s -bash root pts/0 192.168.211.1 02:54 1.00s 1.23s 0.01s w -------------------- Last logins: root pts/0 Tue Jun 7 02:54 still logged in 192.168.211.1 root pts/4 Mon Jun 6 15:45 - 20:15 (04:29) 192.168.211.1 root tty1 Mon Jun 6 15:45 still logged in -------------------- Disk and memory usage: Free/total disk: 3.6G / 3.6G Free/total memory: 0 / 7411 MB -------------------- OOM errors since Jun 5 11:55 : 0 -------------------- Utilization and most expensive processes: top - 16:12:17 up 1 day, 20:24, 2 users, load average: 1.61, 1.61, 1.63 Tasks: 295 total, 2 running, 195 sleeping, 0 stopped, 0 zombie %Cpu(s): 20.0 us, 8.7 sy, 0.0 ni, 70.9 id, 0.0 wa, 0.0 hi, 0.5 si, 0.0 st PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 71469 998 20 0 152880 69196 12508 R 100.0 0.9 0:04.19 bundle 3160 998 20 0 1438356 892316 25176 S 17.6 11.8 474:58.71 bundle 8 root 20 0 0 0 0 I 11.8 0.0 29:12.26 rcu_sched -------------------- Open TCP ports: server-health.sh: line 26: nmap: command not found -------------------- Current connections: Total: 1543 (kernel 6994) TCP: 29 (estab 2, closed 17, orphaned 0, synrecv 0, timewait 0/0), ports 0 Transport Total IP IPv6 * 6994 - - RAW 1 0 1 UDP 3 2 1 TCP 12 11 1 INET 16 13 3 FRAG 0 0 0 -------------------- processes: USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 2 0.0 0.0 0 0 ? S Jun05 0:00 [kthreadd] root 4 0.0 0.0 0 0 ? I Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:49:26 "},"Case/Monitor/shell_disk.html":{"url":"Case/Monitor/shell_disk.html","title":"shell 磁盘空间","keywords":"","body":"Shell 磁盘空间1. Shell 磁盘空间使用率Shell 磁盘空间 tagsstart 监控 tagsstop 1. Shell 磁盘空间使用率 disk-space.sh MAX=95 EMAIL=server@127.0.0.1 PART=sda1 USE=$(df -h | grep $PART | awk '{ print $5 }' | cut -d'%' -f1) USE=`printf \"%.0f\\n\" $USE` if [ $USE -gt $MAX ]; then echo \"Percent used: $USE\" | mail -s \"Running out of disk space\" $EMAIL else echo \"all is well\" fi 执行: $ bash disk-space.sh all is well 更多阅读： fio测试磁盘io工具 磁盘 I/O 性能优化的几个思路 为什么我的磁盘I/O延迟很高？ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:52:21 "},"Case/Monitor/shell_weather.html":{"url":"Case/Monitor/shell_weather.html","title":"shell 天气预报","keywords":"","body":"Shell 天气预报Shell 天气预报 tagsstart 监控 tagsstop weather.sh #!/bin/bash # weather.sh # Copyright 2018 computer-geek64. All rights reserved. program=Weather version=1.1 year=2018 developer=computer-geek64 case $1 in -h | --help) echo \"$program $version\" echo \"Copyright $year $developer. All rights reserved.\" echo echo \"Usage: weather [options]\" echo \"Option Long Option Description\" echo \"-h --help Show the help screen\" echo \"-l [location] --location [location] Specifies the location\" ;; -l | --location) curl https://wttr.in/$2 ;; *) curl https://wttr.in ;; esac 执行： $ bash weather.sh -h Weather 1.1 Copyright 2018 computer-geek64. All rights reserved. Usage: weather [options] Option Long Option Description -h --help Show the help screen -l [location] --location [location] Specifies the location $ bash weather.sh $ bash weather.sh -l shanghai Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:45:09 "},"Case/Monitor/shell_CPU.html":{"url":"Case/Monitor/shell_CPU.html","title":"shell cpu","keywords":"","body":"shell CPU1. shell CPU 使用率2. CPU 检查shell CPU tagsstart 监控 tagsstop 1. shell CPU 使用率 CPU.sh ```bash MAX=95 EMAIL=server@127.0.0.1 USE=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage \"\"}') USE=printf \"%.0f\\n\" $USE if [[ $USE -gt $MAX ]]; then echo \"Percent used: $USE\" | mail -s \"Running out of CPU power\" $EMAIL else echo \"all is well !\" fi 执行： ```bash $ bash CPU.sh all is well ! 2. CPU 检查 #!/bin/bash ################################################################################# # ActiveXperts Network Monitor - Shell script checks # # For more information about ActiveXperts Network Monitor and SSH, please # visit the online ActiveXperts Network Monitor Shell Script Guidelines at: # https://www.activexperts.com/support/network-monitor/online/linux/ ################################################################################# # Script # cpu.sh # Description # Checks CPU usage on the computer. # Declare Parameters # 1) nMaxCpuUsage (number) - maximum allowed CPU usage (%) # Usage # cpu.sh nMaxCpuUsage # Sample # cpu.sh 70 ################################################################################# nMaxCpuUsage=$1 # Validate number of arguments if [ $# -ne 1 ] ; then echo \"UNCERTAIN: Invalid number of arguments - Usage: cpu nMaxCpuUsage\" exit 1 fi # Validate numeric parameter nMaxCpuUsage regExpNumber='^[0-9]+$' if ! [[ $1 =~ $regExpNumber ]] ; then echo \"UNCERTAIN: Invalid argument: nMaxCpuUsage (number expected)\" exit 1 fi # Check the CPU usage nCpuLoadPercentage=`ps -A -o pcpu | tail -n+2 | paste -sd+ | bc` nCpuLoadPercentage=$( echo \"$nCpuLoadPercentage / 1\" | bc ) if [ $nCpuLoadPercentage -le $nMaxCpuUsage ] ; then echo \"SUCCESS: CPU usage is [$nCpuLoadPercentage%], minimum allowed=[$1%] DATA:$nCpuLoadPercentage\" else echo \"ERROR: CPU usage is [$nCpuLoadPercentage%], minimum allowed=[$1%] DATA:$nCpuLoadPercentage\" fi exit 0 执行： $ bash nmaxcpu.sh 70 SUCCESS: CPU usage is [0%], minimum allowed=[70%] DATA:0 $ bash nmaxcpu.sh 80 SUCCESS: CPU usage is [0%], minimum allowed=[80%] DATA:0 更多阅读： CPU使用率达到100%怎么办？ 系统中的软中断使用率升高怎么办？ 如何快速分析出CPU的瓶颈？ CPU使用率高却找不到应用？ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 18:05:41 "},"Case/Monitor/shell_hardware.html":{"url":"Case/Monitor/shell_hardware.html","title":"shell 硬件信息","keywords":"","body":"Shell 硬件信息Shell 硬件信息 tagsstart 监控 tagsstop HardwareInfo.sh #!/usr/bin/env bash # ------------------------------------------------------------------------ # # Script Name: hardware_machine.sh # Description: Show informations about machine hardware. # Written by: Amaury Souza # Maintenance: Amaury Souza # ------------------------------------------------------------------------ # # Usage: # $ ./hardware_machine.sh # ------------------------------------------------------------------------ # # Bash Version: # Bash 4.4.19 # ------------------------------------------------------------------------ # function menuprincipal () { clear TIME=1 echo \" \" echo $0 echo \" \" echo \"Choose an option below! 1 - Verify desktop processor 2 - Verify system kernel 3 - Verify installed softwares 4 - Operation system version 5 - Verify desktop memory 6 - Verify serial number 7 - Verify system IP 0 - Exit\" echo \" \" echo -n \"Chosen option: \" read opcao case $opcao in 1) function processador () { CPU_INFO=`cat /proc/cpuinfo | grep -i \"^model name\" | cut -d \":\" -f2 | sed -n '1p'` echo \"CPU model: $CPU_INFO\" sleep $TIME } processador read -n 1 -p \" for main menu\" menuprincipal ;; 2) function kernel () { #RED HAT: cat /etc/redhat-release KERNEL_VERSION_UBUNTU=`uname -r` KERNEL_VERSION_CENTOS=`uname -r` if [ -f /etc/lsb-release ] then echo \"kernel version: $KERNEL_VERSION_UBUNTU\" else echo \"kernel version: $KERNEL_VERSION_CENTOS\" fi } kernel read -n 1 -p \" for main menu\" menuprincipal ;; 3) function softwares () { #while true; do TIME=3 echo \" \" echo \"Choose an option below for program's list! 1 - List Ubuntu programs 2 - List Fedora programs 3 - Install programs 4 - Back to menu\" echo \" \" echo -n \"Chosen option: \" read alternative case $alternative in 1) echo \"Listing all programs Ubuntu's systems...\" sleep $TIME dpkg -l > /tmp/programs.txt echo Programs listed and available at /tmp sleep $TIME echo \" \" echo \"Back to menu!\" | tr [a-z] [A-Z] sleep $TIME ;; 2) echo \"Listing all programs Fedora's systems...\" sleep $TIME yum list installed > /tmp/programs.txt echo Programs listed and available at /tmp sleep $TIME ;; 3) echo Installing programss... LIST_OF_APPS=\"pinta brasero gimp vlc inkscape blender filezilla\" #use aptitude command for programs loop. apt install aptitude -y aptitude install -y $LIST_OF_APPS ;; 4) echo Back to main menu... sleep $TIME ;; esac #done } softwares menuprincipal ;; 4) function sistema () { VERSION=`cat /etc/os-release | grep -i ^PRETTY` if [ -f /etc/os-release ] then echo \"The system version: $VERSION\" else echo \"System not supported\" fi } sistema read -n 1 -p \" for main menu\" menuprincipal ;; 5) function memory () { MEMORY_FREE=`free -m | grep ^Mem | tr -s ' ' | cut -d ' ' -f 4` #MEMORY_TOTAL= #MEMORY_USED= echo Verifying system memory... echo \"Memory free is: $MEMORY_FREE\" } memory read -n 1 -p \" for main menu\" menuprincipal ;; 6) function serial () { SERIAL_NUMBER=`dmidecode -t 1 | grep -i serial` echo $SERIAL_NUMBER } serial read -n 1 -p \" for main menu\" menuprincipal ;; 7) function ip () { IP_SISTEMA=`hostname -I` echo IP is: $IP_SISTEMA } ip read -n 1 -p \" for main menu\" menuprincipal ;; 0) echo Exiting the system... sleep $TIME exit 0 ;; *) echo Invalid option, try again! ;; esac } menuprincipal 执行: $ bash hardware_machine.sh hardware_machine.sh Choose an option below! 1 - Verify desktop processor 2 - Verify system kernel 3 - Verify installed softwares 4 - Operation system version 5 - Verify desktop memory 6 - Verify serial number 7 - Verify system IP 0 - Exit Chosen option: 1 CPU model: Intel(R) Core(TM) i7-6600U CPU @ 2.60GHz Chosen option: 7 IP is: 192.168.211.70 172.18.0.1 172.17.0.1 Chosen option: 2 kernel version: 4.15.0-180-generic Chosen option: 3 Choose an option below for program's list! 1 - List Ubuntu programs 2 - List Fedora programs 3 - Install programs 4 - Back to menu Chosen option: 5 Verifying system memory... Memory free is: 698 Chosen option: 6 Serial Number: VMware-56 4d 67 71 20 7d eb e5-97 b4 bb 44 a3 d3 5f c6 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:53:52 "},"Case/Monitor/shell_get_ip_address.html":{"url":"Case/Monitor/shell_get_ip_address.html","title":"shell 获取 ip 位置","keywords":"","body":"Shell 获取 IP 位置Shell 获取 IP 位置 tagsstart 监控 tagsstop whereIP.sh #!/usr/bin/env bash # # Author: Abhishek Shingane (abhisheks@iitbhilai.ac.in) # Date: 11 Sep 2020 # if ! [ -x \"$(command -v jq)\" ]; then echo 'Error: jq is not installed. Install via https://stedolan.github.io/jq/download/' exit 1 fi if [[ $# -ne 1 ]]; then echo 'Provide I.P as command line parameter. Usage: ' $0 ' 15.45.0.1 ' exit 1 fi link=$(echo \"http://ip-api.com/json/\"$1) data=$(curl $link -s) # -s for slient output status=$(echo $data | jq '.status' -r) if [[ $status == \"success\" ]]; then city=$(echo $data | jq '.city' -r) regionName=$(echo $data | jq '.regionName' -r) country=$( echo $data | jq '.country' -r) echo $city, $regionName in $country. fi 执行： $ bash whereIP.sh 8.8.8.8 Ashburn, Virginia in United States. $ bash whereIP.sh 114.114.114.114 Weifang, Shandong in China. Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:46:44 "},"Case/Monitor/shell_os_message.html":{"url":"Case/Monitor/shell_os_message.html","title":"shell 显示系统信息菜单","keywords":"","body":"shell 显示系统信息菜单1. 一次交互2. 循环交互shell 显示系统信息菜单 tagsstart 监控 tagsstop 1. 一次交互 Read-Menu.sh #!/usr/bin/env bash # read-menu: a menu driven system information program clear cat &2 exit 1 esac 执行： $ bash read-menu.sh Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 0 Program terminated. $ bash read-menu.sh Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 1 Hostname: yourdomain.com 04:27:46 up 1 day, 8:40, 2 users, load average: 1.74, 1.66, 1.64 $ bash read-menu.sh Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 2 Filesystem Size Used Avail Use% Mounted on udev 3.6G 0 3.6G 0% /dev tmpfs 742M 75M 667M 11% /run /dev/mapper/ubuntu--vg-ubuntu--lv 19G 19G 0 100% / tmpfs 3.7G 0 3.7G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 3.7G 0 3.7G 0% /sys/fs/cgroup /dev/mapper/data-lvdata 40G 15G 26G 37% /data /dev/sda2 976M 220M 690M 25% /boot overlay 40G 15G 26G 37% /data/docker/overlay2/e0be8abd3b18e4c43604eb7a21bc4a6cd40d26290dcaf126a7ecc4ce4463803f/merged overlay 40G 15G 26G 37% /data/docker/overlay2/263af3bac5540d800f30cb0302129810f7a12b9c0aa075c5bb5ef9c3e404e694/merged overlay 40G 15G 26G 37% /data/docker/overlay2/c8c0ac7f5b991aa62b7786dc0adacf00685d03c42556080572936da9053eb89a/merged tmpfs 742M 0 742M 0% /run/user/0 $ bash read-menu.sh Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 3 Home Space Utilization (All Users) 32K /home/ghostwritten 2. 循环交互 while-menu.sh #!/bin/bash # while-menu: a menu driven system information program DELAY=1 # Number of seconds to display results while true; do clear cat \" case \"$REPLY\" in 0) break ;; 1) echo \"Hostname: $HOSTNAME\" uptime ;; 2) df -h ;; 3) if [[ $(id -u) -eq 0 ]]; then echo \"Home Space Utilization (All Users)\" du -sh /home/* else echo \"Home Space Utilization ($USER)\" du -sh $HOME fi ;; *) echo \"Invalid entry.\" ;; esac sleep \"$DELAY\" done echo \"Program terminated.\" 执行： $ bash read-menu.sh Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 0 Program terminated. Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 1 Hostname: yourdomain.com 04:27:46 up 1 day, 8:40, 2 users, load average: 1.74, 1.66, 1.64 Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 2 Filesystem Size Used Avail Use% Mounted on udev 3.6G 0 3.6G 0% /dev tmpfs 742M 75M 667M 11% /run /dev/mapper/ubuntu--vg-ubuntu--lv 19G 19G 0 100% / tmpfs 3.7G 0 3.7G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 3.7G 0 3.7G 0% /sys/fs/cgroup /dev/mapper/data-lvdata 40G 15G 26G 37% /data /dev/sda2 976M 220M 690M 25% /boot overlay 40G 15G 26G 37% /data/docker/overlay2/e0be8abd3b18e4c43604eb7a21bc4a6cd40d26290dcaf126a7ecc4ce4463803f/merged overlay 40G 15G 26G 37% /data/docker/overlay2/263af3bac5540d800f30cb0302129810f7a12b9c0aa075c5bb5ef9c3e404e694/merged overlay 40G 15G 26G 37% /data/docker/overlay2/c8c0ac7f5b991aa62b7786dc0adacf00685d03c42556080572936da9053eb89a/merged tmpfs 742M 0 742M 0% /run/user/0 Please Select: 1. Display System Information 2. Display Disk Space 3. Display Home Space Utilization 0. Quit Enter selection [0-3]: 3 Home Space Utilization (All Users) 32K /home/ghostwritten Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:34:16 "},"Case/shell_hello_world.html":{"url":"Case/shell_hello_world.html","title":"hello world","keywords":"","body":"Hello WorldHello World hello-world.sh #!/usr/bin/env bash echo \"Hello World!\" 执行： $ bash hello-world.sh Hello World! Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-15 12:00:04 "},"Case/Math/":{"url":"Case/Math/","title":"Math","keywords":"","body":"shell 数学shell 数学 数学在Bash脚本中使用吗？数学经常用于脚本，尤其是在编写复杂的 crontab 报告、监控插件、使用动态配置设置脚本或其他自动化任务（如显示 Raspberry PI CPU 温度）时。总是需要进行一些算术计算。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:33:48 "},"Case/Math/shell_subtraction.html":{"url":"Case/Math/shell_subtraction.html","title":"shell 减法","keywords":"","body":"Shell 减法1. 数字相减Shell 减法 tagsstart 数学 tagsstop 1. 数字相减 subtraction.sh #!/usr/bin/env bash printf \"Enter the First Number: \" read -r a printf \"Enter the Second Number: \" read -r b echo \"$a - $b = $((a - b))\" 执行： $ bash subtraction.sh Enter the First Number: 3 Enter the Second Number: 4 3 - 4 = -1 $ bash subtraction.sh Enter the First Number: 5 Enter the Second Number: 3 5 - 3 = 2 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:35:32 "},"Case/Math/shell_Multiplication.html":{"url":"Case/Math/shell_Multiplication.html","title":"shell 乘法","keywords":"","body":"shell 乘法1. 乘法口诀shell 乘法 tagsstart 数学 tagsstop 1. 乘法口诀 cheng.sh #!/bin/bash # for i in `seq 9` do for j in `seq $i` do echo -n \"$i*$j=$[i*j] \" done echo done $ bash cheng.sh 1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:21:00 "},"Case/Math/shell_rock-paper-scissors.html":{"url":"Case/Math/shell_rock-paper-scissors.html","title":"shell 石头剪刀布","keywords":"","body":"shell 石头剪刀布shell 石头剪刀布 tagsstart 数学 tagsstop compare.sh #!/bin/bash #1.列出计算机随即选择的可能. #2.列出人人为选择的方式. #3.表达计算机的选择结果与人的做出比较. #4.布置虚拟现实环境. game=(石头 剪刀 布) num=$[RANDOM%3] echo \"请根据下列提示选择您的出拳手势\" echo \"1.石头\" echo \"2.剪刀\" echo \"3.布\" read -p \"请选择1-3:\" num2 echo \"计算机选择：${game[$num]}\" case $num2 in 1) if [[ $num -eq 0 ]];then echo \"平局\" elif [[ $num -eq 1 ]];then echo \"你赢啦\" else echo \"计算机赢啦\" fi ;; 2) if [[ $num -eq 0 ]];then echo \"计算机赢啦\" elif [[ $num -eq 1 ]];then echo \"平局\" else echo \"你赢啦\" fi ;; 3) if [[ $num -eq 0 ]];then echo \"你赢啦\" elif [[ $num -eq 1 ]];then echo \"计算机赢啦\" else echo \"平局\" fi ;; *) echo \"必须输入1-3的数字\" esac 执行： $ bash compare2.sh 请根据下列提示选择您的出拳手势 1.石头 2.剪刀 3.布 请选择1-3:1 计算机选择：剪刀 你赢啦 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:39:01 "},"Case/Math/shell_compare.html":{"url":"Case/Math/shell_compare.html","title":"shell  比较大小","keywords":"","body":"shell 比较大小三个数值shell 比较大小 tagsstart 数学 tagsstop 三个数值 三个数值由小到大： compare1.sh #!/bin/bash echo -n \"Enter three number:\" read a b c if [ $a -gt $b ];then t=$a;a=$b;b=$t; fi if [ $a -gt $c ];then t=$a;a=$c;c=$t; fi if [ $b -gt $c ];then t=$b;b=$c;c=$t; fi echo \"From small to big:$a,$b,$c\" 执行： $ bash compare1.sh Enter three number: 2 4 3 From small to big:2,3,4 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:37:40 "},"Case/Math/shell_addition.html":{"url":"Case/Math/shell_addition.html","title":"shell 加法","keywords":"","body":"Shell 加法1. 两数字相加2. while3. for4. awk（效率更高）Shell 加法 tagsstart 数学 tagsstop 1. 两数字相加 #!/usr/bin/env bash echo -n 'Enter the First Number: ' read -r a echo -n 'Enter the Second Number: ' read -r b echo \"$a + $b = $((a+b))\" 执行： $ bash addition.sh Enter the First Number: 1 Enter the Second Number: 2 1 + 2 = 3 2. while #!/bin/bash read -p \"请输入一个数字：\" num NUM=${num:-100} SUM=0 i=1 while [ $i -le $NUM ] do let SUM+=i let i++ done echo \"$SUM\" $ bash sum1.sh 请输入一个数字：10 55 3. for #!/bin/bash read -p \"请输入一个数字：\" num NUM=${num:-100} SUM=0 i=1 for i in `seq $NUM` do SUM=$[SUM+i] let i++ done echo \"$SUM\" $ bash for1.sh 请输入一个数字：10 55 4. awk（效率更高） [root@localhost awk]# cat awk1.sh #!/bin/bash sum=0 for((i=0;i [root@localhost awk]# cat awk2.sh #!/bin/bash awk 'BEGIN{while(i++ Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:30:58 "},"Case/Game/":{"url":"Case/Game/","title":"Game","keywords":"","body":"shell 游戏shell 游戏 学习是艰苦的工作，没有人喜欢工作。这意味着无论学习 Bash / Shell 多么容易，对您来说它仍然可能是一种工作。当然，除非你通过游戏学习。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:51:15 "},"Case/Game/shell_lottery.html":{"url":"Case/Game/shell_lottery.html","title":"shell 模拟抽奖","keywords":"","body":"shell 模拟抽奖shell 模拟抽奖 tagsstart 游戏 tagsstop 随机滚动电影名，ctrl + c暂停 $ cat films.txt 银翼杀手 阿凡达 黑镜 复仇联盟 荒岛余生 降临 地心引力 云图 #!/bin/bash film=`cat films.txt | wc -l` while : do numfilm=$[RANDOM%$film+1] #filmname=`head -$numfilm films.txt | tail -1` filmname=`sed -n \"${numfilm}p\" films.txt` echo \"$filmname\" sleep 1 clear done $ bash while1.sh 地心引力 ^C Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:42:00 "},"Case/Art/":{"url":"Case/Art/","title":"Art","keywords":"","body":"Shell 艺术Shell 艺术 Shell 可以勾勒那些看似无用的视觉杰作。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:58:51 "},"Case/Art/shell_spinner_loading.html":{"url":"Case/Art/shell_spinner_loading.html","title":"shell 微调加载","keywords":"","body":"shell 微调加载shell 微调加载 tagsstart 艺术 tagsstop affect.sh #!/usr/bin/env bash arr=('-' '\\' '|' '/') while true; do for c in \"${arr[@]}\"; do echo -en \"\\r $c \" sleep .5 done done 执行： Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 15:54:13 "},"Case/Art/shell_diamond.html":{"url":"Case/Art/shell_diamond.html","title":"shell 菱形图案","keywords":"","body":"shell 菱形图案shell 菱形图案 tagsstart 艺术 tagsstop special-pattern.sh #!/bin/bash MAX_NO=0 echo -n \"Enter Number between (5 to 9) : \" read MAX_NO if ! [ $MAX_NO -ge 5 -a $MAX_NO -le 9 ]; then echo \"WTF... I ask to enter number between 5 and 9, Try Again\" exit 1 fi clear for ((i = 1; i = i; s--)); do echo -n \" \" done for ((j = 1; j = 1; i--)); do for ((s = i; s 执行： bash special-pattern.sh Enter Number between (5 to 9) : 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Whenever you need help, Tecmint.com is always there bash special-pattern.sh Enter Number between (5 to 9) : 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Whenever you need help, Tecmint.com is always there Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:16:39 "},"Case/Art/shell_upper_lower.html":{"url":"Case/Art/shell_upper_lower.html","title":"shell  大小写","keywords":"","body":"Shell 大小写1. Shell 大写转小写Shell 大小写 tagsstart 艺术 tagsstop 1. Shell 大写转小写 $ cat test ABC convertlowercase.sh #!/usr/bin/env bash echo -n \"Enter File Name: \" read -r file if [ ! -f \"$file\" ]; then echo \"Filename $file does not exists\" exit 1 fi tr '[:upper:]' '[:lower:]' 执行： $ bash convertlowercase.sh Enter File Name: test abc Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:15:13 "},"Case/Art/shell_color.html":{"url":"Case/Art/shell_color.html","title":"shell 颜色输出","keywords":"","body":"shell 颜色输出shell 颜色输出 tagsstart 艺术 tagsstop color.sh #!/usr/bin/env bash for c in 90 31 91 32 33 34 35 95 36 97; do echo -en \"\\r \\e[${c}m LOVE \\e[0m \" sleep 1 done 执行： Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:12:33 "},"Case/shell_command_return.html":{"url":"Case/shell_command_return.html","title":"shell 命令输出","keywords":"","body":"shell 命令输出shell 命令输出 process.sh #!/usr/bin/env bash echo \"Hello $USER\" echo \"Hey i am $USER and will be telling you about the current processes\" echo \"Running processes List\" ps 执行： $ bash process.sh Hello root Hey i am root and will be telling you about the current processes Running processes List PID TTY TIME CMD 6898 pts/0 00:00:00 bash 29530 pts/0 00:00:00 bash 29531 pts/0 00:00:00 ps Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 08:08:13 "},"Case/shell_read.html":{"url":"Case/shell_read.html","title":"shell 简单交互","keywords":"","body":"shell 简单交互shell 简单交互 interactive.sh #! /bin/bash echo \"Hey what's Your First Name?\" read a echo \"welcome Mr./Mrs. $a, would you like to tell us, Your Last Name\" read b echo \"Thanks Mr./Mrs. $a $b for telling us your name\" echo \"*******************\" echo \"Mr./Mrs. $b, it's time to say you good bye\" 执行： $ bash interactive.sh Hey what's Your First Name? jack welcome Mr./Mrs. jack, would you like to tell us, Your Last Name zong Thanks Mr./Mrs. jack zong for telling us your name ******************* Mr./Mrs. zong, it's time to say you good bye Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 08:18:43 "},"Case/Task/":{"url":"Case/Task/","title":"Task","keywords":"","body":"shell 任务shell 任务 收集那些我们日常工作中不得不处理的 shell 小任务。 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:26:04 "},"Case/Task/shell_mount.html":{"url":"Case/Task/shell_mount.html","title":"shell 挂载目录","keywords":"","body":"shell 挂载目录shell 挂载目录 tagsstart 任务 tagsstop # Notes: # - Please install \"jq\" package before using this driver. usage() { err \"Invalid usage. Usage: \" err \"\\t$0 init\" err \"\\t$0 mount \" err \"\\t$0 unmount \" exit 1 } err() { echo -ne $* 1>&2 } log() { echo -ne $* >&1 } ismounted() { MOUNT=`findmnt -n ${MNTPATH} 2>/dev/null | cut -d' ' -f1` if [ \"${MOUNT}\" == \"${MNTPATH}\" ]; then echo \"1\" else echo \"0\" fi } domount() { MNTPATH=$1 local NFS_SERVER=$(echo $2 | jq -r '.server') local SHARE=$(echo $2 | jq -r '.share') local PROTOCOL=$(echo $2 | jq -r '.protocol') local ATIME=$(echo $2 | jq -r '.atime') local READONLY=$(echo $2 | jq -r '.readonly') if [ -n \"${PROTOCOL}\" ]; then PROTOCOL=\"tcp\" fi if [ -n \"${ATIME}\" ]; then ATIME=\"0\" fi if [ -n \"${READONLY}\" ]; then READONLY=\"0\" fi if [ \"${PROTOCOL}\" != \"tcp\" ] && [ \"${PROTOCOL}\" != \"udp\" ] ; then err \"{ \\\"status\\\": \\\"Failure\\\", \\\"message\\\": \\\"Invalid protocol ${PROTOCOL}\\\"}\" exit 1 fi if [ $(ismounted) -eq 1 ] ; then log '{\"status\": \"Success\"}' exit 0 fi mkdir -p ${MNTPATH} &> /dev/null local NFSOPTS=\"${PROTOCOL},_netdev,soft,timeo=10,intr\" if [ \"${ATIME}\" == \"0\" ]; then NFSOPTS=\"${NFSOPTS},noatime\" fi if [ \"${READONLY}\" != \"0\" ]; then NFSOPTS=\"${NFSOPTS},ro\" fi mount -t nfs -o${NFSOPTS} ${NFS_SERVER}:/${SHARE} ${MNTPATH} &> /dev/null if [ $? -ne 0 ]; then err \"{ \\\"status\\\": \\\"Failure\\\", \\\"message\\\": \\\"Failed to mount ${NFS_SERVER}:${SHARE} at ${MNTPATH}\\\"}\" exit 1 fi log '{\"status\": \"Success\"}' exit 0 } unmount() { MNTPATH=$1 if [ $(ismounted) -eq 0 ] ; then log '{\"status\": \"Success\"}' exit 0 fi umount ${MNTPATH} &> /dev/null if [ $? -ne 0 ]; then err \"{ \\\"status\\\": \\\"Failed\\\", \\\"message\\\": \\\"Failed to unmount volume at ${MNTPATH}\\\"}\" exit 1 fi log '{\"status\": \"Success\"}' exit 0 } op=$1 if ! command -v jq >/dev/null 2>&1; then err \"{ \\\"status\\\": \\\"Failure\\\", \\\"message\\\": \\\"'jq' binary not found. Please install jq package before using this driver\\\"}\" exit 1 fi if [ \"$op\" = \"init\" ]; then log '{\"status\": \"Success\", \"capabilities\": {\"attach\": false}}' exit 0 fi if [ $# -lt 2 ]; then usage fi shift case \"$op\" in mount) domount $* ;; unmount) unmount $* ;; *) log '{\"status\": \"Not supported\"}' exit 0 esac exit 1 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:59:54 "},"Case/Task/shell_change_files.html":{"url":"Case/Task/shell_change_files.html","title":"shell 批量修改文件名","keywords":"","body":"shell 批量修改文件名1. 添加2. 修改3. 删除shell 批量修改文件名 tagsstart 任务 tagsstop @[toc] 1. 添加 $ ls file1 file2 file3 file4 $ cat mv1.sh #!/bin/bash for file in `ls file*` do mv $file `echo \"${file}.txt\" ` done $ bash mv1.sh $ ls file1.txt file2.txt file3.txt file4.txt $ ls file.1 file.2 file.3 file.4 $ cat mv1.sh #!/bin/bash for file in `ls file*` do #mv $file `echo ${file}.txt|sed 's/\\.//1' ` mv $file $(echo ${file}.txt|sed 's/\\.//1') done $ bash mv1.sh $ ls file1.txt file2.txt file3.txt file4.txt 2. 修改 $ ls file1.txt file2.txt file3.txt file4.txt $ cat mv3.sh #!/bin/bash for file in `ls file*` do mv $file ${file%.txt}.sh #第一种方法 done $ bash mv3.sh $ ls file1.sh file2.sh file3.sh file4.sh $ cat mv4.sh #!/bin/bash for file in `ls file*` do mv $file `echo $file |sed 's/\\.sh/\\.pdf/'` #第二种方法 done $ bash mv4.sh $ ls file1.pdf file3.pdf file2.pdf file4.pdf 3. 删除 $ ls file1.pdf file3.pdf file2.pdf file4.pdf $ cat mv5.sh #!/bin/bash for file in `ls file*` do mv $file `echo $file |sed 's/\\.pdf//'` done bash mv5.sh $ ls file1 file2 file3 file4 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:31:32 "},"Case/Task/shell_moveup_dir.html":{"url":"Case/Task/shell_moveup_dir.html","title":"shell 上移目录","keywords":"","body":"shell 上移目录shell 上移目录 tagsstart 任务 tagsstop up.sh #!/bin/bash LEVEL=$1 for ((i = 0; i 执行： root@yourdomain:~/shell/shell-docs/scripts# pwd /root/shell/shell-docs/scripts root@yourdomain:~/shell/shell-docs/scripts# bash up.sh You are in: /root root@yourdomain:~# root@yourdomain:~/shell/shell-docs/scripts# bash up.sh 1 0 You are in: /root/shell/shell-docs root@yourdomain:~/shell/shell-docs/scripts# bash up.sh 2 0 1 You are in: /root/shell Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 17:00:07 "},"Case/Task/shell_clean_log.html":{"url":"Case/Task/shell_clean_log.html","title":"shell 清理日志","keywords":"","body":"shell 清理日志1shell 清理日志 tagsstart 任务 tagsstop 1 clean_messages.sh #!/bin/bash LOG_DIR=/var/log ROOT_UID=0 # UID为0的用户才拥有root权限。 LINES=50 # 默认保存messages日志文件行数。 E_XCD=86 # 无法切换工作目录的错误码。 E_NOTROOT=87 # 非root权限用户执行的错误码。 # 请使用root权限运行。 if [ \"$UID\" -ne \"$ROOT_UID\" ] then echo \"Must be root to run this script.\" exit $E_NOTROOT fi if [ -n \"$1\" ] # 测试命令行参数（保存行数）是否为空 then lines=$1 else lines=$LINES # 如果为空则使用默认设置 fi # Stephane Chazelas 建议使用如下方法检查命令行参数， # 但是这已经超出了此阶段教程的范围。 # # E_WRONGARGS=85 # Non-numerical argument (bad argument format). # case \"$1\" in # \"\" ) lines=50;; # *[!0-9]*) echo \"Usage: `basename $0` lines-to-cleanup\"; # exit $E_WRONGARGS;; # * ) lines=$1;; # esac # #* 在第十一章“循环与分支”中会对此作详细的阐述。 cd $LOG_DIR if [ `pwd` != \"$LOG_DIR\" ] # 也可以这样写 if [ \"$PWD\" != \"$LOG_DIR\" ] # 检查工作目录是否为 /var/log ? then echo \"Can't change to $LOG_DIR\" exit $E_XCD fi # 在清理日志前，二次确认是否在正确的工作目录下。 # 更高效的写法： # # cd /var/log || { # echo \"Cannot change to necessary directory.\" >&2 # exit $E_XCD; # } tail -n $lines messages > mesg.temp # 保存messages日志文件最后一部分 mv mesg.temp messages # 替换系统日志文件以达到清理目的 # cat /dev/null > messages #* 我们不需要使用这个方法了，上面的方法更安全 cat /dev/null > wtmp # ': > wtmp' 与 '> wtmp' 有同样的效果 echo \"Log files cleaned up.\" # 注意在/var/log目录下的其他日志文件不会被这个脚本清除 exit 0 # 返回0表示脚本运行成功 执行： $ cat /var/log/messages | wc -l 126 $ bash clean_messages.sh Log files cleaned up. $ cat /var/log/messages | wc -l 50 Copyright © ghostwritten 浙ICP备2020032454号 2022 all right reserved，powered by Gitbook该文件修订时间： 2022-06-22 16:27:00 "}}